<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sava - Lobby</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚öîÔ∏è</text></svg>">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="/static/js/game-config.js"></script>
    <link rel="stylesheet" href="/static/css/lobby.css">
</head>
<body>
    <!-- Hamburger menu button -->
    <button class="hamburger-menu" id="hamburger-menu" onclick="toggleSidebar()">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
    </button>
    
    <!-- Chat toggle button -->
    <button class="chat-toggle" id="chat-toggle" onclick="toggleChat()">
        <div class="chat-icon">üí¨</div>
    </button>
    
    <!-- Mobile overlay -->
    <div class="mobile-overlay" id="mobile-overlay" onclick="closeSidebar()"></div>
    

    
    <div class="container">
        <div class="lobby-content">
            <div class="lobby-sidebar">
                <div class="lobby-header">
                    <div class="logo">‚ôî‚ôõ</div>
                    <h1>Sava</h1>
                    <h2 class="dev-feature">Game Lobby</h2>
                    <div class="lobby-id dev-feature inline" id="lobby-id">{{ lobby_id }}</div>
                </div>
                
                <div class="nav-bar">
                    <a href="/" class="nav-btn">‚Üê Back to Home</a>
                    <button class="nav-btn" onclick="openRulesSidebar()">üìñ Rules</button>
                </div>
                
                <div class="game-status">
                    <span class="status-indicator status-waiting" id="status-indicator"></span>
                    <span id="status-text">Waiting for players...</span>
                </div>

                <div class="turn-timer" id="turn-timer" style="display: none;">
                    <h4>Turn Timer</h4>
                    <div class="timer-display">
                        <div class="timer-section red">
                            <div class="timer-label">Red Player</div>
                            <div class="timer-value" id="red-timer">--:--</div>
                        </div>
                        <div class="timer-section blue">
                            <div class="timer-label">Blue Player</div>
                            <div class="timer-value" id="blue-timer">--:--</div>
                        </div>
                        <div class="current-turn-timer">
                            <div class="timer-label">Current Turn</div>
                            <div class="timer-value" id="current-turn-timer">00:00</div>
                        </div>
                    </div>
                </div>

                <div class="player-section">
                    <h3>Players (0/2)</h3>
                    <ul class="player-list" id="player-list">
                        <li class="player-item">Waiting for players to join...</li>
                    </ul>
                </div>

                <div class="captured-pieces">
                    <h4>Captured by Red</h4>
                    <div class="captured-pieces-list" id="red-captured">
                        <!-- Red's captured pieces will be displayed here -->
                    </div>
                    <h4>Captured by Blue</h4>
                    <div class="captured-pieces-list" id="blue-captured">
                        <!-- Blue's captured pieces will be displayed here -->
                    </div>
                </div>

                <div class="player-section">
                    <h3>Spectators</h3>
                    <ul class="player-list" id="spectator-list">
                        <li class="player-item">No spectators</li>
                    </ul>
                </div>

                <div class="share-link">
                    <h4>Share this link:</h4>
                    <input type="text" id="share-url" readonly>
                    <button class="copy-btn" onclick="copyShareLink()">Copy Link</button>
                </div>
            </div>

                        <div class="game-board-container">
                <div class="game-board" id="game-board">
                    <!-- Game board will be created by JavaScript -->
                </div>
                
                <!-- Game controls -->
                <div style="margin-top: 1rem; text-align: center;">
                    <!-- Weaponmaster move controls -->
                    <div id="weaponmaster-controls" style="display: none; margin-bottom: 0.5rem;">
                        <button class="btn secondary" onclick="gameBoard.cancelWeaponmasterMove()">
                            Cancel Weaponmaster Move
                        </button>
                    </div>
                    
                    <!-- Spider dice button -->
                    <div id="spider-dice-controls" style="margin-bottom: 0.5rem;">
                        <button class="btn spider-dice dice-roll-button" id="spider-dice-btn" onclick="gameBoard.rollSpiderDice()" title="Roll two d8 dice: 5-8 = üï∑Ô∏è (spider), 1-4 = üî™ (knife). Double spiders trigger special effects!" disabled>
                            üï∑Ô∏è Roll Spider Dice
                        </button>
                        <div style="font-size: 0.8rem; color: #666; margin-top: 0.25rem; text-align: center;">
                            üï∑Ô∏è = Success, üî™ = Knife
                        </div>
                    </div>
                    
                    <!-- Board refresh button -->
                    <button class="btn secondary dev-feature" id="refresh-board-btn" onclick="gameBoard.refreshBoard()" style="margin-top: 0.5rem;">
                        üîÑ Refresh Board
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Chat Window -->
        <div class="chat-window" id="chat-window">
            <div class="chat-header">
                <div class="chat-title">üí¨ Chat</div>
                <button class="close-chat-btn" onclick="closeChat()">√ó</button>
            </div>
            
            <div class="chat-messages" id="chat-messages">
                <div class="chat-welcome">Welcome to the lobby! Start chatting with other players.</div>
            </div>
            
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="Type a message..." maxlength="500" onkeypress="handleChatKeyPress(event)">
                <button class="send-btn" onclick="sendChatMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Rain effect container -->
    <div class="rain-container" id="rain-container"></div>
    
    <!-- Game over overlay -->
    <div class="game-over-overlay" id="game-over-overlay">
        <div class="game-over-content">
            <div class="game-over-title" id="game-over-title">Game Over</div>
            <div class="game-over-message" id="game-over-message">The game has ended</div>
            <button class="game-over-btn" onclick="closeGameOverOverlay()">Close</button>
        </div>
    </div>
    
    <!-- Spider dice result overlay -->
    <div class="dice-result" id="dice-result">
        <h3>üï∑Ô∏è Spider Dice Results</h3>
        <div class="dice-results">
            <div class="die" id="die1">?</div>
            <div class="die" id="die2">?</div>
        </div>
        <div id="dice-message">Rolling...</div>
        <button class="btn spider-dice" onclick="closeDiceResult()" style="margin-top: 1rem;">Close</button>
    </div>

    <!-- Rules Sidebar -->
    <div class="rules-overlay" id="rules-overlay"></div>
    <div class="rules-sidebar" id="rules-sidebar">
        <div class="rules-header">
            <div class="rules-title">üìñ Game Rules</div>
            <button class="close-rules-btn" onclick="closeRulesSidebar()">√ó</button>
        </div>
        
        <div class="rules-content" id="rules-content">
            <div class="loading">Loading rules...</div>
        </div>
    </div>

    <!-- Orc Promotion Modal -->
    <div class="promotion-overlay" id="promotion-overlay">
        <div class="promotion-modal">
            <div class="promotion-header">
                <h3>üîÑ Orc Promotion</h3>
                <p>Your orc has reached enemy territory! Choose a captured piece to resurrect:</p>
            </div>
            
            <div class="promotion-pieces" id="promotion-pieces">
                <!-- Available pieces will be populated here -->
            </div>
            
            <div class="promotion-footer">
                <button class="btn secondary" onclick="closePromotionModal()">Cancel</button>
                <button class="promotion-confirm" id="promotion-confirm-btn" onclick="confirmPromotion()" disabled>
                    Select a piece first
                </button>
            </div>
        </div>
    </div>

    <script>
        let playerId = null;
        let playerRole = null;
        let gameBoard = null;
        let lobbyState = null;
        let socket = null;

        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        // Initialize lobby
        async function initializeLobby() {
            playerId = generatePlayerId();
            const lobbyId = document.getElementById('lobby-id').textContent;
            
            // Set share URL
            const shareUrl = window.location.origin + '/lobby/' + lobbyId;
            document.getElementById('share-url').value = shareUrl;

            // Initialize WebSocket connection
            initializeWebSocket(lobbyId);

            // Join lobby
            try {
                const response = await fetch(`/api/lobby/${lobbyId}/join`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        player_id: playerId,
                        player_name: `Player ${playerId.slice(-4)}`
                    })
                });

                const data = await response.json();
                playerRole = data.role;
                lobbyState = data.lobby_info;
                
                updateLobbyDisplay();
                
                // Only initialize the board after we have the lobby state
                if (lobbyState && lobbyState.game_state) {
                    initializeGameBoard().catch(error => {
                        console.error('Failed to initialize game board:', error);
                    });
                } else {
                    console.log('Waiting for game state before initializing board...');
                }
            } catch (error) {
                console.error('Failed to join lobby:', error);
            }
        }

        // Initialize WebSocket connection
        function initializeWebSocket(lobbyId) {
            socket = io();
            
            // Handle connection events
            socket.on('connect', function() {
                console.log('WebSocket connected');
                
                // Join the lobby room after connection is established
                socket.emit('join_lobby', {
                    lobby_id: lobbyId,
                    player_id: playerId
                });
            });
            
            socket.on('disconnect', function() {
                console.log('WebSocket disconnected');
            });
            
            // Listen for lobby updates
            socket.on('lobby_update', function(data) {
                console.log('WebSocket update received:', data);
                handleLobbyUpdate(data);
            });
            
            // Listen for sacrifice errors
            socket.on('sacrifice_error', function(data) {
                console.error('Sacrifice error:', data.error);
                document.getElementById('status-text').textContent = 'Sacrifice failed: ' + data.error;
            });
            
            // Listen for spider control errors
            socket.on('spider_control_error', function(data) {
                console.error('Spider control error:', data.error);
                document.getElementById('status-text').textContent = 'Spider control failed: ' + data.error;
            });
            
            // Listen for controlled move errors
            socket.on('controlled_move_error', function(data) {
                console.error('Controlled move error:', data.error);
                document.getElementById('status-text').textContent = 'Controlled move failed: ' + data.error;
            });
            
            // Listen for chat errors
            socket.on('chat_error', function(data) {
                console.error('Chat error:', data.error);
                // You could show an error message in the chat window here
            });

            // Listen for timeout events
            socket.on('player_timeout', function(data) {
                console.log('‚è∞ Player timeout event received:', data);
                updateTimerDisplay();
                stopTurnTimer();
            });

            socket.on('timeout_error', function(data) {
                console.error('Timeout error:', data.error);
            });

            // Listen for promotion errors
            socket.on('promotion_error', function(data) {
                console.error('Promotion error:', data.error);
                document.getElementById('status-text').textContent = 'Promotion failed: ' + data.error;
                closePromotionModal();
            });
        }

        // Handle lobby updates from WebSocket
        function handleLobbyUpdate(data) {
            const { event_type, lobby_info, data: eventData } = data;
            
            // Update local state
            lobbyState = lobby_info;
            
            // Update display
            updateLobbyDisplay();
            
            // Update captured pieces display (only if game has started)
            if (lobby_info.game_state && lobby_info.game_state.game_started) {
                updateCapturedPieces();
            }
            
                    // Handle specific events
        switch (event_type) {
            case 'game_started':
                console.log('Game started via WebSocket');
                if (gameBoard && lobby_info.game_state.board) {
                    gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                }
                const currentTurn = lobby_info.game_state.current_turn;
                document.getElementById('status-text').textContent = 
                    `Game in progress - ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn`;
                document.getElementById('status-indicator').className = 'status-indicator status-playing';
                
                // Update spider dice button state when game starts
                updateSpiderDiceButtonState();
                break;
                
            case 'game_over':
                // console.log('üéÆ Game over via WebSocket - full event data:', eventData);
                // console.log('üéÆ Event data structure:', JSON.stringify(eventData, null, 2));
                handleGameOver(eventData);
                
                // Stop timer when game ends
                stopTurnTimer();
                
                // Update spider dice button state when game ends
                updateSpiderDiceButtonState();
                break;
                    
                case 'piece_moved':
                    console.log('Piece moved via WebSocket');
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    
                    // Update status with move information
                    const moveInfo = lobby_info.game_state.last_move;
                    if (moveInfo) {
                        let statusText = `${moveInfo.player.charAt(0).toUpperCase() + moveInfo.player.slice(1)} moved ${moveInfo.piece} from ${moveInfo.from} to ${moveInfo.to}`;
                        if (moveInfo.captured) {
                            if (Array.isArray(moveInfo.captured) && moveInfo.captured.length > 0) {
                                if (moveInfo.captured.length === 1) {
                                    statusText += ` (captured ${moveInfo.captured[0]})`;
                                } else {
                                    statusText += ` (captured ${moveInfo.captured.join(', ')})`;
                                }
                            } else if (moveInfo.captured) {
                                // Handle single capture for backward compatibility
                                statusText += ` (captured ${moveInfo.captured})`;
                            }
                        }
                        const currentTurn = lobby_info.game_state.current_turn;
                        statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        document.getElementById('status-text').textContent = statusText;
                    }
                    
                    // Clear any current selection since it's not our turn
                    gameBoard.clearLegalMoveIndicators();
                    if (gameBoard.selectedNode) {
                        gameBoard.selectedNode.classList.remove('selected');
                        gameBoard.selectedNode = null;
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Update spider dice button state after piece move
                    updateSpiderDiceButtonState();
                    
                    // Show check indicators after move
                    if (gameBoard && gameBoard.showCheckIndicators) {
                        gameBoard.showCheckIndicators();
                    }
                    break;
                    
                case 'piece_sacrificed':
                    console.log('Piece sacrificed via WebSocket');
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    
                    // Exit sacrifice mode
                    if (gameBoard) {
                        gameBoard.exitSacrificeMode();
                    }
                    
                    // Update status with sacrifice information
                    const sacrificeMoveInfo = lobby_info.game_state.last_move;
                    if (sacrificeMoveInfo) {
                        let statusText = `${sacrificeMoveInfo.player.charAt(0).toUpperCase() + sacrificeMoveInfo.player.slice(1)} sacrificed ${sacrificeMoveInfo.piece}`;
                        const currentTurn = lobby_info.game_state.current_turn;
                        statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        document.getElementById('status-text').textContent = statusText;
                    }
                    
                    // Clear any current selection since it's not our turn
                    gameBoard.clearLegalMoveIndicators();
                    if (gameBoard.selectedNode) {
                        gameBoard.selectedNode.classList.remove('selected');
                        gameBoard.selectedNode = null;
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Update spider dice button state after sacrifice
                    updateSpiderDiceButtonState();
                    
                    // Show check indicators after sacrifice
                    if (gameBoard && gameBoard.showCheckIndicators) {
                        gameBoard.showCheckIndicators();
                    }
                    break;
                    
                case 'enemy_piece_controlled':
                    console.log('Enemy piece controlled via WebSocket');
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    
                    // Highlight the controlled piece
                    const controlledNode = lobby_info.game_state.controlled_piece_node;
                    if (gameBoard && controlledNode) {
                        gameBoard.highlightControlledPiece(controlledNode);
                    }
                    
                    // Update status with control information
                    const controlMoveInfo = lobby_info.game_state.last_move;
                    if (controlMoveInfo) {
                        let statusText = `${controlMoveInfo.player.charAt(0).toUpperCase() + controlMoveInfo.player.slice(1)} took control of ${controlMoveInfo.controlled_piece}`;
                        statusText += '. Now move the controlled piece.';
                        document.getElementById('status-text').textContent = statusText;
                    }
                    break;
                    
                case 'controlled_piece_moved':
                    console.log('Controlled piece moved via WebSocket');
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    
                    // Exit spider control mode
                    if (gameBoard) {
                        gameBoard.exitSpiderControlMode();
                    }
                    
                    // Update status with move information
                    const controlledMoveInfo = lobby_info.game_state.last_move;
                    if (controlledMoveInfo) {
                        let statusText = `${controlledMoveInfo.player.charAt(0).toUpperCase() + controlledMoveInfo.player.slice(1)} moved controlled ${controlledMoveInfo.piece}`;
                        if (controlledMoveInfo.captured && controlledMoveInfo.captured.length > 0) {
                            statusText += ` and captured ${controlledMoveInfo.captured.join(', ')}`;
                        }
                        const currentTurn = lobby_info.game_state.current_turn;
                        statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        document.getElementById('status-text').textContent = statusText;
                    }
                    
                    // Clear any current selection since it's not our turn
                    gameBoard.clearLegalMoveIndicators();
                    if (gameBoard.selectedNode) {
                        gameBoard.selectedNode.classList.remove('selected');
                        gameBoard.selectedNode = null;
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Update spider dice button state
                    updateSpiderDiceButtonState();
                    
                    // Show check indicators after controlled move
                    if (gameBoard && gameBoard.showCheckIndicators) {
                        gameBoard.showCheckIndicators();
                    }
                    break;
                    
                case 'spider_dice_rolled':
                    console.log('Spider dice rolled via WebSocket');
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    
                    // Update status with dice results
                    const diceMoveInfo = lobby_info.game_state.last_move;
                    if (diceMoveInfo && diceMoveInfo.move_type === 'spider_dice_roll') {
                        const diceResults = diceMoveInfo.dice_results;
                        let statusText = `${diceMoveInfo.player.charAt(0).toUpperCase() + diceMoveInfo.player.slice(1)} rolled spider dice: `;
                        statusText += `${diceResults.die1_spider ? 'üï∑Ô∏è' : 'üî™'} and ${diceResults.die2_spider ? 'üï∑Ô∏è' : 'üî™'}`;
                        
                        if (diceResults.both_spiders) {
                            statusText += ' üï∑Ô∏èüï∑Ô∏è DOUBLE SPIDERS! Player can control an enemy piece!';
                            // Enter spider control mode only if the current local player is the one who should control
                            if (gameBoard && lobby_info.game_state?.spider_control_mode) {
                                const currentPlayer = lobby_info.players?.find(p => p.id === playerId);
                                const spiderControlPlayer = lobby_info.game_state?.spider_control_player;
                                if (currentPlayer && currentPlayer.color === spiderControlPlayer) {
                                    gameBoard.enterSpiderControlMode();
                                }
                            }
                        } else if (diceResults.both_knives) {
                            statusText += ' üî™üî™ DOUBLE KNIVES! Player must sacrifice a piece!';
                            // Enter sacrifice mode only if the current local player is the one who must sacrifice
                            if (gameBoard && lobby_info.game_state?.sacrifice_mode) {
                                const currentPlayer = lobby_info.players?.find(p => p.id === playerId);
                                const sacrificePlayer = lobby_info.game_state?.sacrifice_player;
                                if (currentPlayer && currentPlayer.color === sacrificePlayer) {
                                    gameBoard.enterSacrificeMode();
                                }
                            }
                        } else {
                            const spiderCount = (diceResults.die1_spider ? 1 : 0) + (diceResults.die2_spider ? 1 : 0);
                            if (spiderCount === 1) {
                                statusText += ' (1 spider)';
                            } else {
                                statusText += ' (no knives)';
                            }
                        }
                        
                        const currentTurn = lobby_info.game_state.current_turn;
                        statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        
                        document.getElementById('status-text').innerHTML = statusText;
                    }
                    
                    // Clear any current selection since it's not our turn
                    gameBoard.clearLegalMoveIndicators();
                    if (gameBoard.selectedNode) {
                        gameBoard.selectedNode.classList.remove('selected');
                        gameBoard.selectedNode = null;
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Update spider dice button state after dice roll
                    updateSpiderDiceButtonState();
                    break;
                    
                // Duplicate piece_sacrificed case removed - handled above
                    
                case 'player_joined':
                    console.log('Player joined via WebSocket:', eventData);
                    // Force update the lobby display to show the new player
                    updateLobbyDisplay();
                    break;
                    
                case 'player_left':
                    console.log('Player left via WebSocket:', eventData);
                    // Force update the lobby display to reflect the player leaving
                    updateLobbyDisplay();
                    break;
                    
                case 'joined_lobby':
                    console.log('Joined lobby via WebSocket:', lobby_info);
                    // Update the display with the current lobby state
                    updateLobbyDisplay();
                    
                    // Initialize the board if it hasn't been initialized yet and we have game state
                    if (!gameBoard && lobby_info.game_state) {
                        console.log('Initializing game board from WebSocket data...');
                        initializeGameBoard().catch(error => {
                            console.error('Failed to initialize game board from WebSocket:', error);
                        });
                    }
                    
                    // Load existing chat messages
                    loadChatMessages();
                    break;
                    
                case 'chat_message_sent':
                    console.log('Chat message received via WebSocket:', eventData);
                    addChatMessage(eventData);
                    break;
                    
                case 'orc_promotion_available':
                    console.log('Orc promotion available via WebSocket:', eventData);
                    showPromotionModal(eventData);
                    break;
                    
                case 'orc_promoted':
                    console.log('Orc promoted via WebSocket:', eventData);
                    if (gameBoard && lobby_info.game_state.board) {
                        gameBoard.updateBoardWithPieces(lobby_info.game_state.board);
                    }
                    closePromotionModal();
                    
                    // Update status
                    const promotionInfo = lobby_info.game_state.last_move;
                    if (promotionInfo && promotionInfo.move_type === 'orc_promotion') {
                        let statusText = `${promotionInfo.player.charAt(0).toUpperCase() + promotionInfo.player.slice(1)} promoted ${promotionInfo.promoted_from} to ${promotionInfo.promoted_to}`;
                        const currentTurn = lobby_info.game_state.current_turn;
                        statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        document.getElementById('status-text').textContent = statusText;
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Show check indicators after promotion
                    if (gameBoard && gameBoard.showCheckIndicators) {
                        gameBoard.showCheckIndicators();
                    }
                    break;
                    
                default:
                    console.log('Unknown event type:', event_type);
            }
        }

        // Update lobby display
        function updateLobbyDisplay() {
            if (!lobbyState) return;

            // Update player count
            const playerCount = lobbyState.players?.length || 0;
            document.querySelector('.player-section h3').textContent = `Players (${playerCount}/2)`;

            // Update player list
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            
            if (!lobbyState.players || lobbyState.players.length === 0) {
                playerList.innerHTML = '<li class="player-item">Waiting for players to join...</li>';
            } else {
                lobbyState.players.forEach(player => {
                    const li = document.createElement('li');
                    li.className = 'player-item';
                    // Prepare player display name
                    let displayName = player.name;
                    if (window.SHOW_PLAYER_IDS && player.id) {
                        displayName += ` (${player.id.slice(-4)})`;
                    }
                    
                    li.innerHTML = `
                        <div class="player-avatar">${player.name.slice(0, 2).toUpperCase()}</div>
                        <div class="player-info">
                            <div class="player-name">${displayName}</div>
                            <div class="player-role">${player.color} player</div>
                        </div>
                    `;
                    playerList.appendChild(li);
                });
            }

            // Update spectator list
            const spectatorList = document.getElementById('spectator-list');
            spectatorList.innerHTML = '';
            
            if (lobbyState.spectators.length === 0) {
                spectatorList.innerHTML = '<li class="player-item">No spectators</li>';
            } else {
                lobbyState.spectators.forEach(spectator => {
                    const li = document.createElement('li');
                    li.className = 'player-item spectator';
                    li.innerHTML = `
                        <div class="player-avatar">üëÅ</div>
                        <div class="player-info">
                            <div class="player-name">${spectator.name}</div>
                            <div class="player-role">Spectator</div>
                        </div>
                    `;
                    spectatorList.appendChild(li);
                });
            }

            // Update status
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');

            if (lobbyState.game_state.game_started) {
                // Game is already started
                statusIndicator.className = 'status-indicator status-playing';
                const currentTurn = lobbyState.game_state.current_turn;
                const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                if (currentPlayer) {
                    const playerTurnCount = lobbyState.game_state.player_turn_numbers?.[currentPlayer.color] || 0;
                    statusText.textContent = `Game in progress - Your turn count: ${playerTurnCount} - ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn`;
                } else {
                    statusText.textContent = `Game in progress - ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn`;
                }
            } else if (lobbyState.can_start) {
                // Ready to start but not started yet
                statusIndicator.className = 'status-indicator status-ready';
                statusText.textContent = 'Starting game automatically...';
            } else {
                // Waiting for players
                statusIndicator.className = 'status-indicator status-waiting';
                statusText.textContent = `Waiting for players... (${playerCount}/2)`;
            }
            
            // Update spider dice button state when lobby display is updated
            if (lobbyState.game_state && lobbyState.game_state.game_started) {
                updateSpiderDiceButtonState();
                // Update timer display
                updateTimerDisplay();
                // Start timer if game is active
                if (!lobbyState.game_state.game_over) {
                    startTurnTimer();
                }
            } else {
                // Stop timer if game hasn't started or is over
                stopTurnTimer();
            }
        }

        // Chat functionality
        function toggleChat() {
            const chatWindow = document.getElementById('chat-window');
            const chatToggle = document.getElementById('chat-toggle');
            
            if (chatWindow.classList.contains('open')) {
                closeChat();
            } else {
                openChat();
            }
        }

        function openChat() {
            const chatWindow = document.getElementById('chat-window');
            const chatToggle = document.getElementById('chat-toggle');
            
            chatWindow.classList.add('open');
            chatToggle.classList.add('active');
            
            // Focus on chat input
            setTimeout(() => {
                document.getElementById('chat-input').focus();
            }, 50);
        }

        function closeChat() {
            const chatWindow = document.getElementById('chat-window');
            const chatToggle = document.getElementById('chat-toggle');
            
            chatWindow.classList.remove('open');
            chatToggle.classList.remove('active');
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        async function sendChatMessage() {
            const chatInput = document.getElementById('chat-input');
            const message = chatInput.value.trim();
            
            if (!message) return;
            
            if (message.length > 500) {
                alert('Message too long (max 500 characters)');
                return;
            }
            
            const sendBtn = document.querySelector('.send-btn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'Sending...';
            
            try {
                const lobbyId = document.getElementById('lobby-id').textContent;
                
                // Send via WebSocket
                socket.emit('send_chat_message', {
                    lobby_id: lobbyId,
                    message: message,
                    player_id: playerId
                });
                
                // Clear input
                chatInput.value = '';
                
            } catch (error) {
                console.error('Failed to send chat message:', error);
                alert('Failed to send message. Please try again.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
            }
        }

        function loadChatMessages() {
            if (!lobbyState || !lobbyState.game_state || !lobbyState.game_state.chat_messages) {
                return;
            }
            
            const chatMessages = document.getElementById('chat-messages');
            // Clear welcome message if it exists
            const welcomeMessage = chatMessages.querySelector('.chat-welcome');
            if (welcomeMessage) {
                welcomeMessage.remove();
            }
            
            // Load all existing messages
            lobbyState.game_state.chat_messages.forEach(message => {
                addChatMessage(message, false); // false = don't animate
            });
        }

        function addChatMessage(messageData, animate = true) {
            const chatMessages = document.getElementById('chat-messages');
            
            // Remove welcome message if it exists
            const welcomeMessage = chatMessages.querySelector('.chat-welcome');
            if (welcomeMessage) {
                welcomeMessage.remove();
            }
            
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message';
            
            // Determine if this is our own message
            const isOwnMessage = messageData.player_id === playerId;
            const isSpectator = messageData.is_spectator;
            
            if (isOwnMessage) {
                messageElement.classList.add('own');
            } else if (isSpectator) {
                messageElement.classList.add('spectator');
            } else {
                messageElement.classList.add('other');
            }
            
            if (animate) {
                messageElement.classList.add('new');
            }
            
            // Format timestamp
            const timestamp = new Date(messageData.timestamp);
            const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            // Determine player color class
            let playerColorClass = '';
            if (isSpectator) {
                playerColorClass = 'spectator';
            } else {
                playerColorClass = messageData.player_color || 'spectator';
            }
            
            messageElement.innerHTML = `
                <div class="message-header">
                    <span class="player-name ${playerColorClass}">${messageData.player_name}</span>
                    ${isSpectator ? '<span class="spectator-badge">(Spectator)</span>' : ''}
                    <span class="message-timestamp">${timeString}</span>
                </div>
                <div class="message-content">${escapeHtml(messageData.message)}</div>
            `;
            
            chatMessages.appendChild(messageElement);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Remove new animation class after animation completes
            if (animate) {
                setTimeout(() => {
                    messageElement.classList.remove('new');
                }, 300);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            if (!lobbyState || !lobbyState.game_state || !lobbyState.game_state.captured_pieces) return;            
            const redCaptured = document.getElementById('red-captured');
            const blueCaptured = document.getElementById('blue-captured');
            
            // Clear existing displays
            redCaptured.innerHTML = '';
            blueCaptured.innerHTML = '';
            
            // Display red's captured pieces
            lobbyState.game_state.captured_pieces.red.forEach(pieceName => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'captured-piece blue'; // Blue pieces captured by red
                pieceElement.textContent = getPieceSymbol(pieceName);
                pieceElement.title = pieceName;
                redCaptured.appendChild(pieceElement);
            });
            
            // Display blue's captured pieces
            lobbyState.game_state.captured_pieces.blue.forEach(pieceName => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'captured-piece red'; // Red pieces captured by blue
                pieceElement.textContent = getPieceSymbol(pieceName);
                pieceElement.title = pieceName;
                blueCaptured.appendChild(pieceElement);
            });
        }

        // Copy share link
        function copyShareLink() {
            const shareUrl = document.getElementById('share-url');
            shareUrl.select();
            document.execCommand('copy');
            
            const copyBtn = document.querySelector('.copy-btn');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        }

        // Game board class
        class MolecularBoard {
            constructor() {
                this.board = document.getElementById('game-board');
                this.nodes = [];
                this.selectedNode = null;
                this.weaponmasterMode = false;
                this.firstNode = null;
                this.weaponmasterMoves = [];
                this.wizardMode = false;
                this.wizardFirstNode = null;
                this.wizardSecondNode = null;
                this.wizardMoves = [];
                this.sacrificeMode = false;
                this.spiderControlMode = false;
                this.controlledPieceNode = null;
                this.controlledWeaponmasterMode = false;
                this.controlledWeaponmasterMoves = [];
                this.controlledFirstNode = null;
                
                // Store initial dimensions for resize detection
                this.lastWidth = window.innerWidth;
                this.lastHeight = window.innerHeight;
                
                // Check if GAME_CONFIG is loaded before initializing board
                if (GAME_CONFIG) {
                    console.log('üéØ GAME_CONFIG available, initializing board immediately');
                    this.initializeBoard();
                } else {
                    console.log('üéØ GAME_CONFIG not loaded yet, waiting...');
                    // Wait for GAME_CONFIG to load
                    this.waitForGameConfig();
                }
                
                this.setupResizeDetection();
            }
            
            async waitForGameConfig() {
                let attempts = 0;
                const maxAttempts = 50; // Wait up to 5 seconds
                
                while (!GAME_CONFIG && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (GAME_CONFIG) {
                    console.log('üéØ GAME_CONFIG loaded after waiting, initializing board');
                    this.initializeBoard();
                } else {
                    console.error('üéØ GAME_CONFIG failed to load after waiting');
                }
            }

            setupResizeDetection() {
                window.addEventListener('resize', () => {
                    this.onResize();
                });
            }

            onResize() {
                try {
                    const currentWidth = window.innerWidth;
                    const currentHeight = window.innerHeight;

                    if (currentWidth !== this.lastWidth || currentHeight !== this.lastHeight) {
                        devLog('üîÑ Window resize detected:', {
                            old: { width: this.lastWidth, height: this.lastHeight },
                            new: { width: currentWidth, height: currentHeight }
                        });
                        
                        this.lastWidth = currentWidth;
                        this.lastHeight = currentHeight;
                        
                        // Store current game state before reinitializing
                        const currentBoardState = lobbyState?.game_state?.board || {};
                        const currentSelection = this.selectedNode ? this.selectedNode.getAttribute('data-id') : null;
                        const currentWeaponmasterMode = this.weaponmasterMode;
                        const currentWizardMode = this.wizardMode;
                     
                        // Re-initialize board to apply new scaling
                        this.initializeBoard();
                        
                        // Restore game state after reinitializing
                        if (Object.keys(currentBoardState).length > 0) {
                            this.updateBoardWithPieces(currentBoardState);
                            
                            // Restore selection if there was one
                            if (currentSelection) {
                                const nodeToSelect = this.nodes.find(n => n.id === currentSelection);
                                if (nodeToSelect) {
                                    nodeToSelect.element.classList.add('selected');
                                    this.selectedNode = nodeToSelect.element;
                                    
                                    // Restore special move modes
                                    if (currentWeaponmasterMode) {
                                        this.weaponmasterMode = true;
                                        this.getLegalMoves(currentSelection);
                                        console.log('‚öîÔ∏è Weaponmaster mode restored');
                                    } else if (currentWizardMode) {
                                        this.wizardMode = true;
                                        this.getLegalMoves(currentSelection);
                                    } else {
                                        // Regular piece selection - get legal moves
                                        this.getLegalMoves(currentSelection);
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è Could not restore selection - node not found:', currentSelection);
                                }
                            }
                            
                            // Ensure complete game state restoration
                            setTimeout(() => {
                                this.restoreGameStateAfterResize();
                            }, 100); // Small delay to ensure DOM is ready
                        } else {
                            console.log('‚ÑπÔ∏è No game state to restore (game not started yet)');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error during resize handling:', error);
                    // Fallback: try to refresh the board completely
                    try {
                        console.log('üîÑ Attempting fallback board refresh...');
                        this.refreshBoard();
                    } catch (fallbackError) {
                        console.error('‚ùå Fallback refresh also failed:', fallbackError);
                    }
                }
            }

            initializeBoard() {
                this.board.innerHTML = '';
                this.nodes = [];
                
                // Calculate center based on board size
                const boardRect = this.board.getBoundingClientRect();
                const boardWidth = this.board.offsetWidth;
                const boardHeight = this.board.offsetHeight;
                this.centerX = boardWidth / 2;
                this.centerY = boardHeight / 2;
                
                // Calculate dynamic scaling factor based on window size
                const baseWindowSize = 1200; // Reference window width
                const scaleFactor = Math.max(0.8, Math.min(1.8, window.innerWidth / baseWindowSize));
                
                // Apply scaling to board dimensions with increased base sizes
                const scaledCenterOffset = GAME_CONFIG.board_scaling.center_offset * scaleFactor * 0.8; // Reduce from 1.2 to 0.8 to move nodes further inwards
                const scaledMaxRadius = Math.min(boardWidth, boardHeight) * 0.45; // Increase from 0.35 to 0.45 to fill more space
                const scaledNodeSize = Math.max(30, Math.min(50, GAME_CONFIG.board_scaling.node_size * scaleFactor * 1.3)); // Increase node size
                
                // Create center nodes (4 nodes in a square) with scaled positioning
                const centerPositions = [
                    {x: this.centerX - scaledCenterOffset, y: this.centerY - scaledCenterOffset},
                    {x: this.centerX + scaledCenterOffset, y: this.centerY - scaledCenterOffset},
                    {x: this.centerX - scaledCenterOffset, y: this.centerY + scaledCenterOffset},
                    {x: this.centerX + scaledCenterOffset, y: this.centerY + scaledCenterOffset}
                ];

                centerPositions.forEach((pos, index) => {
                    this.createNode(pos.x, pos.y, `C${index}`, 'center', scaledNodeSize);
                });

                // Create concentric rings with expanded radii to fill the container
                const ringRadii = [scaledMaxRadius * 0.35, scaledMaxRadius * 0.7, scaledMaxRadius]; // Increase first ring from 0.3 to 0.35 for better node spacing
                ringRadii.forEach((radius, ringIndex) => {
                    this.createRing(radius, ringIndex + 1, scaledNodeSize);
                });

                // Create connecting strands with scaled dimensions
                this.createStrands(scaleFactor, scaledMaxRadius);
            }

            createNode(x, y, id, type, nodeSize) {
                const node = document.createElement('div');
                node.className = 'node';
                
                // Apply scaled dimensions
                node.style.width = nodeSize + 'px';
                node.style.height = nodeSize + 'px';
                node.style.fontSize = Math.max(0.6, Math.min(1.2, 0.8 * (nodeSize / 20))) + 'rem';
                node.style.borderWidth = Math.max(1, Math.min(3, 2 * (nodeSize / 20))) + 'px';
                
                // Position with scaled offset
                node.style.left = (x - nodeSize / 2) + 'px';
                node.style.top = (y - nodeSize / 2) + 'px';
                
                node.setAttribute('data-id', id);
                node.setAttribute('data-type', type);
                node.setAttribute('data-x', x);
                node.setAttribute('data-y', y);
                
                // Only show node labels in development mode
                if (GAME_CONFIG?.development?.enabled) {
                    node.textContent = id;
                } else {
                    node.textContent = '';
                }
                
                node.addEventListener('click', (e) => this.handleNodeClick(e));
                
                this.board.appendChild(node);
                this.nodes.push({id, x, y, type, element: node});
            }

            createRing(radius, ringIndex, nodeSize) {
                const nodesPerRing = 16;
                for (let i = 0; i < nodesPerRing; i++) {
                    const angle = (i * 2 * Math.PI) / nodesPerRing;
                    const x = this.centerX + radius * Math.cos(angle);
                    const y = this.centerY + radius * Math.sin(angle);
                    const id = `R${ringIndex}N${i}`;
                    this.createNode(x, y, id, `ring${ringIndex}`, nodeSize);
                }
            }

            createStrands(scaleFactor, maxRadius) {
                // Ring strands (circular) - use the same ring radii as the nodes
                const ringRadii = [maxRadius * 0.35, maxRadius * 0.7, maxRadius]; // Match the updated node ring radii
                
                // Apply scaled strand dimensions
                const scaledStrandWidth = Math.max(1, Math.min(4, 2 * scaleFactor));
                
                ringRadii.forEach((radius, index) => {
                    const ringStrand = document.createElement('div');
                    ringStrand.className = 'strand ring';
                    ringStrand.style.left = (this.centerX - radius) + 'px';
                    ringStrand.style.top = (this.centerY - radius) + 'px';
                    ringStrand.style.width = (radius * 2) + 'px';
                    ringStrand.style.height = (radius * 2) + 'px';
                    ringStrand.style.borderWidth = scaledStrandWidth + 'px';
                    this.board.appendChild(ringStrand);
                });

                // Additional connecting strands through specific nodes
                this.createNodeConnections(scaleFactor);
            }

            createNodeConnections(scaleFactor) {
                // Create SVG for curved strands
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', this.board.offsetWidth);
                svg.setAttribute('height', this.board.offsetHeight);
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.zIndex = '5';
                this.board.appendChild(svg);

                // Create strands using shared configuration with scaled stroke width
                GAME_CONFIG.strand_definitions.forEach(strandDef => {
                    this.createCurvedStrand(svg, strandDef.nodes, strandDef.direction, scaleFactor);
                });
            }

            createCurvedStrand(svg, nodeIds, direction, scaleFactor) {
                const nodes = nodeIds.map(id => this.nodes.find(n => n.id === id)).filter(n => n);
                
                if (nodes.length < 2) return;

                // Create path through node centers
                let pathData = '';
                
                nodes.forEach((node, index) => {
                    const x = node.x;
                    const y = node.y;
                    
                    if (index === 0) {
                        pathData += `M ${x} ${y}`;
                    } else {
                        // Calculate control points for smooth curves
                        const prevNode = nodes[index - 1];
                        const nextNode = nodes[index + 1];
                        
                        if (nextNode) {
                            // Use quadratic curve for smooth transitions
                            const midX = (x + prevNode.x) / 2;
                            const midY = (y + prevNode.y) / 2;
                            pathData += ` Q ${midX} ${midY} ${x} ${y}`;
                        } else {
                            // Last node, just line to it
                            pathData += ` L ${x} ${y}`;
                        }
                    }
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#333');
                path.setAttribute('stroke-width', Math.max(1, Math.min(3, 2 * scaleFactor)) + 'px'); // Apply scaled stroke width
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                
                svg.appendChild(path);
            }

            handleNodeClick(event) {
                const node = event.target;
                const nodeId = node.getAttribute('data-id');
                
                console.log('=== NODE CLICK DEBUG ===');
                console.log('Node clicked:', nodeId);
                console.log('Current lobby state:', lobbyState);
                console.log('Player role:', playerRole);
                console.log('üï∑Ô∏è Spider control mode:', this.spiderControlMode);
                console.log('üï∑Ô∏è Controlled piece node:', this.controlledPieceNode);
                
                // Only allow moves if player is a player (not spectator) and it's their turn
                if (playerRole !== 'player') {
                    document.getElementById('status-text').textContent = 'Spectators cannot make moves';
                    return;
                }
                
                // Check if this is a controlled weaponmaster move
                if (this.controlledWeaponmasterMode && this.selectedNode && this.selectedNode.getAttribute('data-id') === this.controlledPieceNode) {
                    if ((node.classList.contains('first-move') || node.classList.contains('second-move'))) {
                        this.handleControlledWeaponmasterMove(nodeId);
                        return;
                    }
                }
                
                // Check if this is a legal move for a previously selected piece
                if (this.selectedNode && node.classList.contains('legal-move')) {
                    const selectedNodeId = this.selectedNode.getAttribute('data-id');
                    
                    // Check if this is a controlled piece move (non-weaponmaster)
                    if (this.controlledPieceNode === selectedNodeId && !this.controlledWeaponmasterMode) {
                        // Check if this node has a stored move path (for complex moves like weaponmaster)
                        const movePath = node.getAttribute('data-move-path');
                        if (movePath) {
                            console.log('üï∑Ô∏è Executing controlled complex move with path:', movePath);
                            this.moveControlledPiece(selectedNodeId, movePath);
                        } else {
                            console.log('üï∑Ô∏è Executing controlled simple move:', selectedNodeId, '->', nodeId);
                            this.moveControlledPiece(selectedNodeId, nodeId);
                        }
                    } else {
                        // Regular piece move
                        this.executeMove(selectedNodeId, nodeId, playerId);
                    }
                    return;
                }
                
                // Check if this is a weaponmaster move
                if (this.selectedNode && this.weaponmasterMode && (node.classList.contains('first-move') || node.classList.contains('second-move'))) {
                    this.handleWeaponmasterMove(nodeId);
                    return;
                }
                
                // Check if this is a wizard move
                if (this.selectedNode && this.wizardMode && node.classList.contains('wizard-move-3')) {
                    this.handleWizardMove(nodeId);
                    return;
                }
                
                // Check if this is a sacrifice move
                if (this.sacrificeMode && node.classList.contains('sacrifice-candidate')) {
                    // Double-check that this is the correct player who should sacrifice
                    const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                    const sacrificePlayer = lobbyState?.game_state?.sacrifice_player;
                    if (currentPlayer && currentPlayer.color === sacrificePlayer) {
                        this.sacrificePiece(nodeId);
                    } else {
                        console.log('üî™ Not the sacrifice player, ignoring sacrifice attempt');
                        document.getElementById('status-text').textContent = 'Only the player who rolled double knives can sacrifice';
                    }
                    return;
                }
                
                // Check if this is a spider control move (selecting enemy piece to control)
                if (this.spiderControlMode && !this.controlledPieceNode && node.classList.contains('spider-control-candidate')) {
                    this.controlEnemyPiece(nodeId);
                    return;
                }
                
                // Clear previous legal move indicators
                this.clearLegalMoveIndicators();
                
                // Remove previous selection
                if (this.selectedNode) {
                    this.selectedNode.classList.remove('selected');
                }
                
                // Reset weaponmaster state when selecting a new piece
                if (this.selectedNode && this.selectedNode !== node) {
                    this.weaponmasterMode = false;
                    this.firstNode = null;
                    this.weaponmasterMoves = [];
                    
                    // Reset wizard state when selecting a new piece
                    this.wizardMode = false;
                    this.wizardMoves = [];
                }
                
                // Check if the clicked node has a piece and if it belongs to the current player
                const boardState = lobbyState?.game_state?.board || {};
                const pieceName = boardState[nodeId];
                
                console.log('Board state:', boardState);
                console.log('Piece at node:', pieceName);
                
                if (pieceName) {
                    // Check if this piece belongs to the current player
                    const currentTurn = lobbyState?.game_state?.current_turn;
                    console.log('Current turn:', currentTurn);
                    console.log('Piece name:', pieceName);
                    console.log('Piece starts with red_:', pieceName.startsWith('red_'));
                    console.log('Piece starts with blue_:', pieceName.startsWith('blue_'));
                    console.log('Piece starts with red :', pieceName.startsWith('red '));
                    console.log('Piece starts with blue :', pieceName.startsWith('blue '));
                    
                    // Safety check: ensure we have a valid current turn
                    if (!currentTurn) {
                        console.error('No current turn found in lobby state');
                        document.getElementById('status-text').textContent = 'Game state error: no current turn found';
                        return;
                    }
                    
                    // Find the current player's color from the lobby state
                    const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                    if (!currentPlayer) {
                        console.error('Current player not found in lobby state');
                        document.getElementById('status-text').textContent = 'Game state error: player not found';
                        return;
                    }
                    
                    const playerColor = currentPlayer.color;
                    console.log('Player color:', playerColor);
                    console.log('Current turn:', currentTurn);
                    
                    // Check if it's the player's turn OR if we're in spider control mode and it's our spider control
                    const isMyTurn = currentTurn === playerColor;
                    const spiderControlMode = lobbyState?.game_state?.spider_control_mode || false;
                    const spiderControlPlayer = lobbyState?.game_state?.spider_control_player;
                    const isMySpiderControl = spiderControlMode && spiderControlPlayer === playerColor;
                    
                    console.log('Is my turn:', isMyTurn);
                    console.log('Spider control mode:', spiderControlMode);
                    console.log('Spider control player:', spiderControlPlayer);
                    console.log('Is my spider control:', isMySpiderControl);
                    
                    // Don't allow moves if it's not our turn and we're not in spider control
                    if (!isMyTurn && !isMySpiderControl) {
                        console.log('Not player turn and not spider control - blocking move');
                        document.getElementById('status-text').textContent = `It's ${currentTurn}'s turn. Wait for your turn.`;
                        return;
                    }
                    
                    // Check if this piece belongs to the current player (not the current turn)
                    // Piece names can be: "red_matron mother", "red_orc_0", "blue_wizard", etc.
                    const isFriendlyPiece = pieceName.startsWith(playerColor + '_') || pieceName.startsWith(playerColor + ' ');
                    console.log('Current turn + "_":', currentTurn + '_');
                    console.log('Current turn + " ":', currentTurn + ' ');
                    console.log('Player color + "_":', playerColor + '_');
                    console.log('Player color + " ":', playerColor + ' ');
                    console.log('Is friendly piece:', isFriendlyPiece);
                    
                    // Check if this is a controlled piece (can select enemy pieces when controlled)
                    const isControlledPiece = this.controlledPieceNode === nodeId;
                    console.log('üï∑Ô∏è CONTROLLED PIECE DEBUG:');
                    console.log('üï∑Ô∏è Controlled piece node:', this.controlledPieceNode);
                    console.log('üï∑Ô∏è Current node clicked:', nodeId);
                    console.log('üï∑Ô∏è Is controlled piece:', isControlledPiece);
                    console.log('üï∑Ô∏è Spider control mode:', this.spiderControlMode);
                    console.log('üï∑Ô∏è Lobby spider control mode:', spiderControlMode);
                    console.log('üï∑Ô∏è Lobby spider control player:', spiderControlPlayer);
                    
                    if (isFriendlyPiece || isControlledPiece) {
                        // This is the player's piece or a controlled enemy piece - select it and show legal moves
                        console.log('Selecting piece (friendly or controlled), getting legal moves');
                        node.classList.add('selected');
                        this.selectedNode = node;
                        
                        // Check if this is a weaponmaster piece
                        if (pieceName.includes('weaponmaster')) {
                            this.weaponmasterMode = true;
                            document.getElementById('status-text').textContent = 
                                `Weaponmaster selected. Click a light green node to start your move, then a dark green node to complete it.`;
                            console.log('Weaponmaster piece selected:', pieceName);
                        }
                        
                        // Check if this is a wizard piece
                        if (pieceName.includes('wizard')) {
                            this.wizardMode = true;
                            document.getElementById('status-text').textContent = 
                                `Wizard selected. Click any highlighted node to move there (all moves are exactly 3 nodes away).`;
                            console.log('Wizard piece selected:', pieceName);
                        }
                        
                        // Use appropriate method to get legal moves
                        if (isControlledPiece) {
                            this.getLegalMovesForControlledPiece(nodeId);
                        } else {
                            this.getLegalMoves(nodeId);
                        }
                    } else {
                        // This is an enemy piece - don't select it (unless it's spider control mode)
                        console.log('Enemy piece clicked, not selecting');
                        document.getElementById('status-text').textContent = 
                            `Cannot select enemy piece. You can only select your own pieces.`;
                        return;
                    }
                } else {
                    // Empty node - just select it (though this might not be useful)
                    console.log('Empty node clicked');
                    node.classList.add('selected');
                    this.selectedNode = node;
                    document.getElementById('status-text').textContent = 
                        `Selected empty node ${nodeId}`;
                }
                console.log('=== END DEBUG ===');
            }

            async executeMove(fromNode, toNode, playerId) {
                try {
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    console.log('Executing move:', { fromNode, toNode, playerId });
                    
                    const response = await fetch(`/api/lobby/${lobbyId}/move`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            from_node: fromNode,
                            to_node: toNode,
                            player_id: playerId
                        })
                    });

                    const data = await response.json();
                    console.log('Move response:', data);
                    
                    if (data.success) {
                        // Update the board with the new state
                        this.updateBoardWithPieces(data.game_state.board);
                        
                        // Clear selection and legal moves
                        this.clearLegalMoveIndicators();
                        if (this.selectedNode) {
                            this.selectedNode.classList.remove('selected');
                            this.selectedNode = null;
                        }
                        
                        // Reset weaponmaster state if this was a weaponmaster move
                        if (this.weaponmasterMode) {
                            this.weaponmasterMode = false;
                            this.firstNode = null;
                            this.weaponmasterMoves = [];
                        }
                        
                        // Always hide weaponmaster controls after any successful move
                        document.getElementById('weaponmaster-controls').style.display = 'none';
                        
                        // Reset wizard state if this was a wizard move
                        if (this.wizardMode) {
                            this.wizardMode = false;
                            this.wizardMoves = [];
                        }
                        
                        // Update status
                        const moveInfo = data.game_state.last_move;
                        if (moveInfo) {
                            let statusText = `${moveInfo.player.charAt(0).toUpperCase() + moveInfo.player.slice(1)} moved ${moveInfo.piece} from ${moveInfo.from} to ${moveInfo.to}`;
                            if (moveInfo.captured) {
                                if (Array.isArray(moveInfo.captured) && moveInfo.captured.length > 0) {
                                    if (moveInfo.captured.length === 1) {
                                        statusText += ` (captured ${moveInfo.captured[0]})`;
                                    } else {
                                        statusText += ` (captured ${moveInfo.captured.join(', ')})`;
                                    }
                                } else if (moveInfo.captured) {
                                    // Handle single capture for backward compatibility
                                    statusText += ` (captured ${moveInfo.captured})`;
                                }
                            }
                            const currentTurn = data.game_state.current_turn;
                            statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                            
                            document.getElementById('status-text').innerHTML = statusText;
                        } else {
                            // Fallback status update
                            const currentTurn = data.game_state.current_turn;
                            document.getElementById('status-text').innerHTML = 
                                `Move completed. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                        }
                        
                        // Update local lobby state to match server
                        if (data.lobby_info) {
                            // Use the full lobby info from the API response
                            lobbyState = data.lobby_info;
                        } else {
                            // Fallback: update just the game state if lobby_info not available
                            if (lobbyState) {
                                lobbyState.game_state = data.game_state;
                            } else {
                                console.warn('lobbyState not initialized, creating minimal structure');
                                lobbyState = {
                                    game_state: data.game_state,
                                    players: [],
                                    spectators: []
                                };
                            }
                        }
                        
                        // Force update of captured pieces display
                        updateCapturedPieces();
                    } else {
                        document.getElementById('status-text').innerHTML = '<strong>Move failed:</strong> ' + (data.error || 'Unknown error');
                    }
                } catch (error) {
                    console.error('Failed to execute move:', error);
                    document.getElementById('status-text').innerHTML = '<strong>Failed to execute move.</strong> Please try again.';
                }
            }
            

            


            async getLegalMoves(nodeId) {
                try {
                    console.log('=== GET LEGAL MOVES DEBUG ===');
                    console.log('Getting legal moves for node:', nodeId);
                    
                    // Double-check: ensure this is a friendly piece before making the API call
                    const boardState = lobbyState?.game_state?.board || {};
                    const pieceName = boardState[nodeId];
                    const currentTurn = lobbyState?.game_state?.current_turn;
                    
                    console.log('Piece name:', pieceName);
                    console.log('Current turn:', currentTurn);
                    
                    if (pieceName && currentTurn) {
                        // Find the current player's color
                        const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                        if (currentPlayer) {
                            const playerColor = currentPlayer.color;
                            const isFriendlyPiece = pieceName.startsWith(playerColor + '_') || pieceName.startsWith(playerColor + ' ');
                            console.log('Player color:', playerColor);
                            console.log('Is friendly piece check:', isFriendlyPiece);
                            if (!isFriendlyPiece) {
                                console.error('getLegalMoves called for enemy piece! This should not happen.');
                                document.getElementById('status-text').textContent = 'Error: Cannot get moves for enemy piece';
                                return;
                            }
                        }
                    }
                    
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    console.log('Making API call to:', `/api/lobby/${lobbyId}/legal-moves/${nodeId}`);
                    const response = await fetch(`/api/lobby/${lobbyId}/legal-moves/${nodeId}`);
                    const data = await response.json();
                    
                    console.log('API response:', data);
                    
                    if (data.error) {
                        document.getElementById('status-text').textContent = 'Error getting legal moves: ' + data.error;
                        return;
                    }
                    
                    if (data.legal_moves.length > 0) {
                        if (this.weaponmasterMode) {
                            // Store weaponmaster moves for parsing
                            this.weaponmasterMoves = data.legal_moves;
                            this.highlightWeaponmasterMoves(data.legal_moves);
                            document.getElementById('status-text').textContent = 
                                `Weaponmaster moves available. Click a light green node to start your move.`;
                        } else if (this.wizardMode) {
                            // Store wizard moves for parsing
                            this.wizardMoves = data.legal_moves;
                            this.highlightWizardMoves(data.legal_moves);
                            document.getElementById('status-text').textContent = 
                                `Wizard moves available. Click any highlighted node to move there.`;
                        } else {
                            this.highlightLegalMoves(data.legal_moves);
                            document.getElementById('status-text').textContent = 
                                `Legal moves for ${nodeId}: ${data.legal_moves.join(', ')}`;
                        }
                    } else {
                        document.getElementById('status-text').textContent = 
                            `No legal moves for ${nodeId}`;
                    }
                    console.log('=== END GET LEGAL MOVES DEBUG ===');
                } catch (error) {
                    console.error('Failed to get legal moves:', error);
                    document.getElementById('status-text').textContent = 'Failed to get legal moves';
                }
            }

            highlightLegalMoves(legalMoves) {
                legalMoves.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('legal-move');
                    }
                });
            }
            
            highlightControlledPieceMoves(legalMoves) {
                console.log('üï∑Ô∏è Highlighting controlled piece moves:', legalMoves);
                
                // Check if the controlled piece is a weaponmaster
                const boardState = lobbyState?.game_state?.board || {};
                const controlledPieceName = boardState[this.controlledPieceNode];
                const isWeaponmaster = controlledPieceName && controlledPieceName.includes('weaponmaster');
                
                console.log('üï∑Ô∏è Controlled piece:', controlledPieceName, 'Is weaponmaster:', isWeaponmaster);
                
                if (isWeaponmaster && legalMoves.some(move => move.includes('->'))) {
                    // Use weaponmaster-style highlighting for path selection
                    console.log('üï∑Ô∏è Using weaponmaster highlighting for controlled piece');
                    this.controlledWeaponmasterMode = true;
                    this.controlledWeaponmasterMoves = legalMoves;
                    this.highlightWeaponmasterMoves(legalMoves);
                    document.getElementById('status-text').textContent = 
                        'üï∑Ô∏è Controlled weaponmaster selected. Click a light green node to start your move, then a dark green node to complete it.';
                } else {
                    // Use simple highlighting for non-weaponmaster pieces
                    this.controlledWeaponmasterMode = false;
                    legalMoves.forEach(move => {
                        if (move.includes('->')) {
                            // Complex move (non-weaponmaster) - highlight the final destination
                            const nodes = move.split('->');
                            const finalDestination = nodes[nodes.length - 1]; // Last node in the path
                            
                            const node = this.nodes.find(n => n.id === finalDestination);
                            if (node) {
                                node.element.classList.add('legal-move');
                                // Store the full move path on the node for later use
                                node.element.setAttribute('data-move-path', move);
                                console.log('üï∑Ô∏è Highlighted complex move destination:', finalDestination, 'for path:', move);
                            } else {
                                console.warn('üï∑Ô∏è Node not found for complex move destination:', finalDestination);
                            }
                        } else {
                            // Simple move - highlight directly
                            const node = this.nodes.find(n => n.id === move);
                            if (node) {
                                node.element.classList.add('legal-move');
                                console.log('üï∑Ô∏è Highlighted simple move:', move);
                            } else {
                                console.warn('üï∑Ô∏è Node not found for simple move:', move);
                            }
                        }
                    });
                }
            }
            
            highlightWeaponmasterMoves(legalMoves) {
                // Parse weaponmaster moves to extract first and second nodes
                const firstNodes = new Set();
                const secondNodes = new Set();
                
                legalMoves.forEach(move => {
                    if (move.includes('->')) {
                        const [firstNode, secondNode] = move.split('->');
                        firstNodes.add(firstNode);
                        secondNodes.add(secondNode);
                    }
                });
                
                // Highlight first nodes in light green
                firstNodes.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('first-move');
                    }
                });
                
                // Highlight second nodes in dark green
                secondNodes.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('second-move');
                    }
                });
                
                console.log('Weaponmaster moves highlighted:', { firstNodes: Array.from(firstNodes), secondNodes: Array.from(secondNodes) });
            }
            
            highlightWizardMoves(legalMoves) {
                // Parse wizard moves - all moves should be three-node paths
                const threeNodeMoves = new Set();
                
                legalMoves.forEach(move => {
                    if (move.includes('->')) {
                        const nodes = move.split('->');
                        if (nodes.length === 3) {
                            // Three-node path: highlight the final destination
                            threeNodeMoves.add(nodes[2]);
                        }
                    }
                });
                
                // Highlight three-node final destinations in dark blue
                threeNodeMoves.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('wizard-move-3');
                    }
                });
                
                console.log('Wizard moves highlighted:', { 
                    threeNodes: Array.from(threeNodeMoves) 
                });
            }
            
            handleWeaponmasterMove(nodeId) {
                if (!this.firstNode) {
                    // First node selection
                    if (this.nodes.find(n => n.id === nodeId)?.element.classList.contains('first-move')) {
                        this.firstNode = nodeId;
                        
                        // Highlight the selected first node
                        const firstNodeElement = this.nodes.find(n => n.id === nodeId)?.element;
                        if (firstNodeElement) {
                            firstNodeElement.classList.remove('first-move');
                            firstNodeElement.classList.add('selected');
                        }
                        
                        // Clear first move indicators and show only valid second moves
                        this.clearLegalMoveIndicators();
                        this.showValidSecondMoves(nodeId);
                        
                        // Show weaponmaster controls
                        document.getElementById('weaponmaster-controls').style.display = 'block';
                        
                        document.getElementById('status-text').textContent = 
                            `First node selected: ${nodeId}. Now click a dark green node to complete your move.`;
                        
                        console.log('First node selected:', nodeId);
                    } else {
                        document.getElementById('status-text').textContent = 
                            `Please click a light green node first to start your weaponmaster move.`;
                    }
                } else {
                    // Second node selection
                    if (this.nodes.find(n => n.id === nodeId)?.element.classList.contains('second-move')) {
                        // Execute the complete weaponmaster move
                        const movePath = `${this.firstNode}->${nodeId}`;
                        console.log('Executing weaponmaster move:', movePath);
                        
                        // Reset weaponmaster state
                        this.weaponmasterMode = false;
                        this.firstNode = null;
                        this.weaponmasterMoves = [];
                        
                        // Execute the move
                        this.executeMove(this.selectedNode.getAttribute('data-id'), movePath, playerId);
                    } else {
                        document.getElementById('status-text').textContent = 
                            `Please click a dark green node to complete your weaponmaster move.`;
                    }
                }
            }
            
            handleControlledWeaponmasterMove(nodeId) {
                if (!this.controlledFirstNode) {
                    // First node selection for controlled weaponmaster
                    if (this.nodes.find(n => n.id === nodeId)?.element.classList.contains('first-move')) {
                        this.controlledFirstNode = nodeId;
                        
                        // Highlight the selected first node
                        const firstNodeElement = this.nodes.find(n => n.id === nodeId)?.element;
                        if (firstNodeElement) {
                            firstNodeElement.classList.remove('first-move');
                            firstNodeElement.classList.add('selected');
                        }
                        
                        // Clear first move indicators and show only valid second moves for controlled piece
                        this.clearLegalMoveIndicators();
                        this.showValidSecondMovesForControlled(nodeId);
                        
                        document.getElementById('status-text').textContent = 
                            `üï∑Ô∏è Controlled weaponmaster first node selected: ${nodeId}. Now click a dark green node to complete the move.`;
                        
                        console.log('üï∑Ô∏è Controlled weaponmaster first node selected:', nodeId);
                    } else {
                        document.getElementById('status-text').textContent = 
                            `üï∑Ô∏è Please click a light green node first to start your controlled weaponmaster move.`;
                    }
                } else {
                    // Second node selection for controlled weaponmaster
                    if (this.nodes.find(n => n.id === nodeId)?.element.classList.contains('second-move')) {
                        // Execute the complete controlled weaponmaster move
                        const movePath = `${this.controlledFirstNode}->${nodeId}`;
                        console.log('üï∑Ô∏è Executing controlled weaponmaster move:', movePath);
                        
                        // Reset controlled weaponmaster state
                        this.controlledWeaponmasterMode = false;
                        this.controlledFirstNode = null;
                        this.controlledWeaponmasterMoves = [];
                        
                        // Execute the controlled move
                        this.moveControlledPiece(this.controlledPieceNode, movePath);
                    } else {
                        document.getElementById('status-text').textContent = 
                            `üï∑Ô∏è Please click a dark green node to complete your controlled weaponmaster move.`;
                    }
                }
            }
            
            showValidSecondMoves(firstNodeId) {
                // Find all valid second nodes for the selected first node
                const validSecondNodes = new Set();
                
                this.weaponmasterMoves.forEach(move => {
                    if (move.includes('->')) {
                        const [firstNode, secondNode] = move.split('->');
                        if (firstNode === firstNodeId) {
                            validSecondNodes.add(secondNode);
                        }
                    }
                });
                
                // Highlight valid second nodes in dark green
                validSecondNodes.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('second-move');
                    }
                });
                
                console.log('Valid second moves shown for', firstNodeId, ':', Array.from(validSecondNodes));
            }
            
            showValidSecondMovesForControlled(firstNodeId) {
                // Find all valid second nodes for the selected first node in controlled weaponmaster moves
                const validSecondNodes = new Set();
                
                this.controlledWeaponmasterMoves.forEach(move => {
                    if (move.includes('->')) {
                        const [firstNode, secondNode] = move.split('->');
                        if (firstNode === firstNodeId) {
                            validSecondNodes.add(secondNode);
                        }
                    }
                });
                
                // Highlight valid second nodes
                validSecondNodes.forEach(nodeId => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.element.classList.add('second-move');
                    }
                });
                
                console.log('üï∑Ô∏è Valid second moves shown for controlled weaponmaster', firstNodeId, ':', Array.from(validSecondNodes));
            }
            
            cancelWeaponmasterMove() {
                // Reset weaponmaster state
                this.weaponmasterMode = false;
                this.firstNode = null;
                this.weaponmasterMoves = [];
                
                // Clear all indicators
                this.clearLegalMoveIndicators();
                
                // Hide controls
                document.getElementById('weaponmaster-controls').style.display = 'none';
                
                // Update status
                document.getElementById('status-text').textContent = 'Weaponmaster move cancelled.';
                
                console.log('Weaponmaster move cancelled');
            }
            
            handleWizardMove(nodeId) {
                // Find the three-node path to reach this destination
                let movePath = null;
                
                // Check if this is a three-node move
                this.wizardMoves.forEach(move => {
                    if (move.includes('->')) {
                        const nodes = move.split('->');
                        if (nodes.length === 3 && nodes[2] === nodeId) {
                            // Three-node path
                            movePath = move;
                        }
                    }
                });
                
                if (!movePath) {
                    console.error('No valid three-node path found for wizard move');
                    document.getElementById('status-text').textContent = 'Invalid wizard move path';
                    return;
                }
                
                console.log('Executing wizard move:', movePath);
                
                // Reset wizard state
                this.wizardMode = false;
                this.wizardMoves = [];
                
                // Execute the move
                this.executeMove(this.selectedNode.getAttribute('data-id'), movePath, playerId);
            }

            clearLegalMoveIndicators() {
                this.nodes.forEach(node => {
                    node.element.classList.remove('legal-move');
                    node.element.classList.remove('first-move');
                    node.element.classList.remove('second-move');
                    node.element.classList.remove('wizard-move-3');
                    // Clear stored move paths for controlled pieces
                    node.element.removeAttribute('data-move-path');
                });
            }

            updateBoardWithPieces(boardState) {                
                if (!boardState || Object.keys(boardState).length === 0) {
                    console.log('üéØ No board state to update');
                    return;
                }
                
                if (!this.nodes || this.nodes.length === 0) {
                    console.error('üéØ No nodes available for piece placement');
                    return;
                }
                
                // Clear all existing pieces
                this.nodes.forEach(node => {
                    // Only show node ID if in development mode
                    if (GAME_CONFIG?.development?.enabled) {
                        node.element.textContent = node.id;
                    } else {
                        node.element.textContent = '';
                    }
                    node.element.style.background = '#fff';
                    node.element.style.borderColor = '#333';
                    node.element.classList.remove('enemy-piece');
                });

                // Place pieces according to board state
                for (const [nodeId, pieceName] of Object.entries(boardState)) {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        // Get the piece symbol based on piece name
                        const pieceSymbol = this.getPieceSymbol(pieceName);
                        if (pieceSymbol) {
                            node.element.textContent = pieceSymbol;
                            
                            // Color the node based on piece color
                            const isRed = pieceName.startsWith('red_');
                            
                            // Default to red styling if currentTurn is not set yet
                            if (isRed) {
                                node.element.style.background = '#ffebee';
                                node.element.style.color = '#c62828';
                                node.element.style.borderColor = '#ef5350';
                            } else {
                                node.element.style.background = '#e3f2fd';
                                node.element.style.color = '#1565c0';
                                node.element.style.borderColor = '#42a5f5';
                            }
                            
                            // Add enemy-piece class if we have a current turn and this is an enemy piece
                            const currentTurn = lobbyState?.game_state?.current_turn;
                            if (currentTurn) {
                                const isEnemyPiece = pieceName.startsWith(currentTurn + '_') === false;
                                if (isEnemyPiece) {
                                    node.element.classList.add('enemy-piece');
                                    node.element.style.opacity = '0.8';
                                } else {
                                    node.element.style.opacity = '1';
                                }
                            } else {
                                // No current turn set yet, default to normal opacity
                                node.element.style.opacity = '1';
                            }
                        } else {
                            console.warn(`üéØ Could not get symbol for piece: ${pieceName}`);
                        }
                    } else {
                        console.warn(`üéØ Node not found for piece placement: ${nodeId}`);
                    }
                }                
                // Update spider dice button state after board update
                updateSpiderDiceButtonState();
                
                // Show check indicators if any player is in check
                if (this.showCheckIndicators) {
                    this.showCheckIndicators();
                }
            }

            getPieceSymbol(pieceName) {
                return GameLogic.getPieceSymbol(pieceName);
            }
            
            restoreGameStateAfterResize() {
                // This method is called after resize to ensure all game state is properly restored
                if (!lobbyState?.game_state?.board) return;
                
                // console.log('Restoring complete game state after resize');
                
                // Update the board with current pieces
                this.updateBoardWithPieces(lobbyState.game_state.board);
                
                // Update captured pieces display
                updateCapturedPieces();
                
                // Update status text if game is over
                if (lobbyState.game_state.game_over) {
                    const gameData = {
                        winner: lobbyState.game_state.winner,
                        game_end_reason: lobbyState.game_state.game_end_reason
                    };
                    handleGameOver(gameData);
                }
            }
            
            handleSidebarToggle(isCollapsed) {
                // This method handles sidebar toggle events to redraw the board elegantly
                // console.log('üîÑ Handling sidebar toggle, isCollapsed:', isCollapsed);
                
                // Store current game state
                const currentBoardState = lobbyState?.game_state?.board || {};
                const currentSelection = this.selectedNode ? this.selectedNode.getAttribute('data-id') : null;
                const currentWeaponmasterMode = this.weaponmasterMode;
                const currentWizardMode = this.wizardMode;
                
                // Force a complete board redraw with new dimensions
                this.initializeBoard();
                
                // Restore game state after redraw
                if (Object.keys(currentBoardState).length > 0) {
                    this.updateBoardWithPieces(currentBoardState);
                    
                    // Restore selection if there was one
                    if (currentSelection) {
                        const nodeToSelect = this.nodes.find(n => n.id === currentSelection);
                        if (nodeToSelect) {
                            nodeToSelect.element.classList.add('selected');
                            this.selectedNode = nodeToSelect.element;
                            console.log('‚úÖ Selection restored after sidebar toggle');
                            
                            // Restore special move modes
                            if (currentWeaponmasterMode) {
                                this.weaponmasterMode = true;
                                this.getLegalMoves(currentSelection);
                                console.log('‚öîÔ∏è Weaponmaster mode restored after sidebar toggle');
                            } else if (currentWizardMode) {
                                this.wizardMode = true;
                                this.getLegalMoves(currentSelection);
                                console.log('üîÆ Wizard mode restored after sidebar toggle');
                            } else {
                                // Regular piece selection - get legal moves
                                this.getLegalMoves(currentSelection);
                                console.log('‚úÖ Legal moves restored after sidebar toggle');
                            }
                        }
                    }
                    
                    // Update captured pieces display
                    updateCapturedPieces();
                    
                    // Update spider dice button state after sidebar toggle
                    updateSpiderDiceButtonState();
                }
            }
            
            async rollSpiderDice() {
                try {
                    console.log('üé≤ Rolling spider dice...');
                    console.log('üé≤ Current game state:', {
                        player_turn_numbers: lobbyState?.game_state?.player_turn_numbers,
                        current_turn: lobbyState?.game_state?.current_turn,
                        player_id: playerId
                    });
                    
                    // Check if it's the current player's turn
                    const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                    if (!currentPlayer) {
                        document.getElementById('status-text').textContent = 'Error: Player not found';
                        return;
                    }
                    
                    const currentTurn = lobbyState?.game_state?.current_turn;
                    if (currentPlayer.color !== currentTurn) {
                        document.getElementById('status-text').textContent = 'Not your turn!';
                        return;
                    }
                    
                    // Start rolling animation
                    const diceBtn = document.getElementById('spider-dice-btn');
                    diceBtn.disabled = true;
                    diceBtn.textContent = 'üé≤ Rolling...';
                    diceBtn.classList.add('rolling');
                    
                    // Update button text to show rolling progress
                    let rollTime = 0;
                    const rollInterval = setInterval(() => {
                        rollTime += 0.5;
                        if (rollTime < 2) {
                            diceBtn.textContent = `üé≤ Rolling... ${rollTime.toFixed(1)}s`;
                        }
                    }, 500);
                    
                    // Stop the rollInterval after 2 seconds
                    setTimeout(() => {
                        clearInterval(rollInterval);
                    }, 2000);
                    
                    // Initialize audio and play dice rolling sound
                    initAudioContext();
                    playDiceRollSound();
                    
                    // Show dice overlay with rolling animation
                    const diceResult = document.getElementById('dice-result');
                    const die1Element = document.getElementById('die1');
                    const die2Element = document.getElementById('die2');
                    const diceMessage = document.getElementById('dice-message');
                    
                    // Set initial rolling state
                    diceMessage.textContent = 'üé≤ Rolling the dice...';
                    die1Element.textContent = 'üé≤';
                    die2Element.textContent = 'üé≤';
                    die1Element.className = 'die rolling-fast';
                    die2Element.className = 'die rolling-fast';
                    
                    // Show the overlay
                    diceResult.classList.add('show');
                    
                    // Update dice message to show rolling progress
                    let diceRollTime = 0;
                    const diceMessageInterval = setInterval(() => {
                        diceRollTime += 0.5;
                        if (diceRollTime < 2) {
                            diceMessage.textContent = `üé≤ Rolling the dice... ${diceRollTime.toFixed(1)}s`;
                        } else {
                            // Stop the interval when rolling is complete
                            clearInterval(diceMessageInterval);
                        }
                    }, 500);
                    
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    const response = await fetch(`/api/lobby/${lobbyId}/roll-spider-dice`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            player_id: playerId
                        })
                    });

                    const data = await response.json();
                    console.log('Spider dice response:', data);
                    
                    if (data.success) {
                        // Update the board with the new state
                        this.updateBoardWithPieces(data.game_state.board);
                        
                        // Clear any current selection
                        this.clearLegalMoveIndicators();
                        if (this.selectedNode) {
                            this.selectedNode.classList.remove('selected');
                            this.selectedNode = null;
                        }
                        
                        // Update status with dice results
                        const moveInfo = data.game_state.last_move;
                        if (moveInfo && moveInfo.move_type === 'spider_dice_roll') {
                            const diceResults = moveInfo.dice_results;
                            let statusText = `${moveInfo.player.charAt(0).toUpperCase() + moveInfo.player.slice(1)} rolled spider dice: `;
                            statusText += `${diceResults.die1_spider ? 'üï∑Ô∏è' : 'üî™'} and ${diceResults.die2_spider ? 'üï∑Ô∏è' : 'üî™'}`;
                            
                            if (diceResults.both_spiders) {
                                statusText += ' üï∑Ô∏èüï∑Ô∏è DOUBLE SPIDERS! Player can control an enemy piece!';
                                // Enter spider control mode only if the current local player is the one who should control
                                if (gameBoard && lobbyState?.game_state?.spider_control_mode) {
                                    const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                                    const spiderControlPlayer = lobbyState.game_state?.spider_control_player;
                                    if (currentPlayer && currentPlayer.color === spiderControlPlayer) {
                                        gameBoard.enterSpiderControlMode();
                                    }
                                }
                            } else if (diceResults.both_knives) {
                                statusText += ' üî™üî™ DOUBLE KNIVES! Player must sacrifice a piece!';
                                // Enter sacrifice mode only if the current local player is the one who must sacrifice
                                if (gameBoard && lobbyState?.game_state?.sacrifice_mode) {
                                    const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                                    const sacrificePlayer = lobbyState.game_state?.sacrifice_player;
                                    if (currentPlayer && currentPlayer.color === sacrificePlayer) {
                                        gameBoard.enterSacrificeMode();
                                    }
                                }
                            } else {
                                const spiderCount = (diceResults.die1_spider ? 1 : 0) + (diceResults.die2_spider ? 1 : 0);
                                if (spiderCount === 1) {
                                    statusText += ' (1 spider)';
                                } else {
                                    statusText += ' (no knives)';
                                }
                            }
                            
                            const currentTurn = data.game_state.current_turn;
                            statusText += `. ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s turn.`;
                            
                            document.getElementById('status-text').innerHTML = statusText;
                            
                            // Stop rolling animation and show final results with bounce
                            clearInterval(rollInterval); // Stop the rolling progress counter
                            clearInterval(diceMessageInterval); // Stop the dice message progress counter
                            setTimeout(() => {
                                showDiceResult(
                                    diceResults.die1,
                                    diceResults.die2,
                                    diceResults.die1_spider,
                                    diceResults.die2_spider,
                                    diceResults.both_spiders,
                                    diceResults.both_knives
                                );
                            }, 2000); // Match the rolling animation duration for dramatic effect
                        }
                        
                        // Update local lobby state
                        if (data.lobby_info) {
                            // Use the full lobby info from the API response
                            lobbyState = data.lobby_info;
                        } else {
                            // Fallback: update just the game state if lobby_info not available
                            if (lobbyState) {
                                lobbyState.game_state = data.game_state;
                            } else {
                                console.warn('lobbyState not initialized, creating minimal structure');
                                lobbyState = {
                                    game_state: data.game_state,
                                    players: [],
                                    spectators: []
                                };
                            }
                        }
                        
                        // Update captured pieces display
                        updateCapturedPieces();
                        
                        // Update spider dice button state after successful roll
                        console.log('üé≤ Updating spider dice button state after successful roll');
                        updateSpiderDiceButtonState();
                    } else {
                        // Hide the dice overlay on failure
                        const diceResult = document.getElementById('dice-result');
                        diceResult.classList.remove('show');
                        
                        // Clear intervals
                        clearInterval(rollInterval);
                        clearInterval(diceMessageInterval);
                        
                        document.getElementById('status-text').innerHTML = '<strong>Spider dice roll failed:</strong> ' + (data.error || 'Unknown error');
                        
                        // Update spider dice button state after failed roll
                        updateSpiderDiceButtonState();
                    }
                } catch (error) {
                    console.error('Failed to roll spider dice:', error);
                    
                    // Hide the dice overlay on error
                    const diceResult = document.getElementById('dice-result');
                    diceResult.classList.remove('show');
                    
                    document.getElementById('status-text').innerHTML = '<strong>Failed to roll spider dice.</strong> Please try again.';
                    
                    // Update spider dice button state after error
                    updateSpiderDiceButtonState();
                } finally {
                    // Re-enable the button and remove rolling animation
                    const diceBtn = document.getElementById('spider-dice-btn');
                    diceBtn.disabled = false;
                    diceBtn.textContent = 'üï∑Ô∏è Roll Spider Dice';
                    diceBtn.classList.remove('rolling');
                    
                    // Clear the rolling progress interval if it exists
                    if (typeof rollInterval !== 'undefined') {
                        clearInterval(rollInterval);
                    }
                    if (typeof diceMessageInterval !== 'undefined') {
                        clearInterval(diceMessageInterval);
                    }
                }
            }
            
            enterSacrificeMode() {
                this.sacrificeMode = true;
                console.log('üî™ Entering sacrifice mode - player must select a piece to sacrifice');
                
                // Check if we are the sacrifice player
                const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                const sacrificePlayer = lobbyState?.game_state?.sacrifice_player;
                
                if (currentPlayer && currentPlayer.color === sacrificePlayer) {
                    document.getElementById('status-text').textContent = 'üî™ Sacrifice a piece... Select one of your own pieces to sacrifice.';
                    // Highlight player's own pieces
                    this.highlightSacrificePieces();
                } else {
                    document.getElementById('status-text').textContent = `üî™ ${sacrificePlayer} player must sacrifice a piece (you rolled double knives).`;
                }
            }
            
            exitSacrificeMode() {
                this.sacrificeMode = false;
                console.log('üî™ Exiting sacrifice mode');
                this.clearSacrificeHighlights();
            }
            
            highlightSacrificePieces() {
                // Clear any existing highlights
                this.clearSacrificeHighlights();
                
                const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                if (!currentPlayer) return;
                
                // Check if the current local player is the one who should sacrifice
                const sacrificePlayer = lobbyState?.game_state?.sacrifice_player;
                if (!sacrificePlayer || currentPlayer.color !== sacrificePlayer) {
                    console.log('üî™ Not the sacrifice player, no highlighting');
                    return;
                }
                
                // Highlight all pieces belonging to the sacrifice player
                Object.entries(lobbyState?.game_state?.board || {}).forEach(([nodeId, pieceName]) => {
                    if (pieceName.startsWith(sacrificePlayer + '_')) {
                        const node = this.nodes.find(n => n.id === nodeId);
                        if (node) {
                            node.element.classList.add('sacrifice-candidate');
                        }
                    }
                });
            }
            
            clearSacrificeHighlights() {
                this.nodes.forEach(node => {
                    node.element.classList.remove('sacrifice-candidate');
                });
            }
            
            async sacrificePiece(nodeId) {
                try {
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    
                    // Emit websocket event for sacrifice
                    socket.emit('sacrifice_piece', {
                        lobby_id: lobbyId,
                        node_id: nodeId,
                        player_id: playerId
                    });
                    
                    console.log('üî™ Sacrificing piece at node:', nodeId);
                } catch (error) {
                    console.error('Failed to sacrifice piece:', error);
                    document.getElementById('status-text').textContent = 'Failed to sacrifice piece. Please try again.';
                }
            }
            
            enterSpiderControlMode() {
                this.spiderControlMode = true;
                console.log('üï∑Ô∏è Entering spider control mode - player must select an enemy piece to control');
                document.getElementById('status-text').textContent = 'üï∑Ô∏è Control an enemy piece... Select an enemy piece to take control of.';
                
                // Highlight enemy pieces
                this.highlightEnemyPieces();
            }
            
            exitSpiderControlMode() {
                this.spiderControlMode = false;
                this.controlledPieceNode = null;
                this.controlledWeaponmasterMode = false;
                this.controlledWeaponmasterMoves = [];
                this.controlledFirstNode = null;
                console.log('üï∑Ô∏è Exiting spider control mode');
                this.clearSpiderControlHighlights();
            }
            
            highlightEnemyPieces() {
                // Clear any existing highlights
                this.clearSpiderControlHighlights();
                
                const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
                if (!currentPlayer) return;
                
                const enemyColor = currentPlayer.color === 'red' ? 'blue' : 'red';
                
                // Highlight all pieces belonging to the enemy (except matron mother)
                Object.entries(lobbyState?.game_state?.board || {}).forEach(([nodeId, pieceName]) => {
                    if (pieceName.startsWith(enemyColor + '_') && !pieceName.includes('matron mother')) {
                        const node = this.nodes.find(n => n.id === nodeId);
                        if (node) {
                            node.element.classList.add('spider-control-candidate');
                        }
                    }
                });
            }
            
            clearSpiderControlHighlights() {
                this.nodes.forEach(node => {
                    node.element.classList.remove('spider-control-candidate');
                    node.element.classList.remove('controlled-piece');
                });
            }
            
            async controlEnemyPiece(nodeId) {
                try {
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    
                    // Emit websocket event for control
                    socket.emit('control_enemy_piece', {
                        lobby_id: lobbyId,
                        node_id: nodeId,
                        player_id: playerId
                    });
                    
                    console.log('üï∑Ô∏è Taking control of enemy piece at node:', nodeId);
                } catch (error) {
                    console.error('Failed to control enemy piece:', error);
                    document.getElementById('status-text').textContent = 'Failed to control enemy piece. Please try again.';
                }
            }
            
            highlightControlledPiece(nodeId) {
                // Clear existing highlights
                this.clearSpiderControlHighlights();
                
                // Highlight the controlled piece
                const node = this.nodes.find(n => n.id === nodeId);
                if (node) {
                    node.element.classList.add('controlled-piece');
                    this.controlledPieceNode = nodeId;
                }
                
                console.log('üï∑Ô∏è Controlled piece highlighted at:', nodeId);
                document.getElementById('status-text').textContent = 'üï∑Ô∏è Move the controlled piece... Click the controlled piece to select it, then click destination.';
            }
            
            async moveControlledPiece(fromNode, toNode) {
                try {
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    
                    // Emit websocket event for controlled move
                    socket.emit('move_controlled_piece', {
                        lobby_id: lobbyId,
                        from_node: fromNode,
                        to_node: toNode,
                        player_id: playerId
                    });
                    
                    console.log('üï∑Ô∏è Moving controlled piece from', fromNode, 'to', toNode);
                } catch (error) {
                    console.error('Failed to move controlled piece:', error);
                    document.getElementById('status-text').textContent = 'Failed to move controlled piece. Please try again.';
                }
            }
            
            async getLegalMovesForControlledPiece(nodeId) {
                try {
                    console.log('üï∑Ô∏è Getting legal moves for controlled piece:', nodeId);
                    // For controlled pieces, we get legal moves using the original piece logic
                    // but we'll allow moves that would normally be illegal (like capturing allies)
                    const lobbyId = document.getElementById('lobby-id').textContent;
                    console.log('üï∑Ô∏è Fetching from API:', `/api/lobby/${lobbyId}/legal-moves/${nodeId}`);
                    const response = await fetch(`/api/lobby/${lobbyId}/legal-moves/${nodeId}`);
                    const data = await response.json();
                    
                    console.log('üï∑Ô∏è API response:', data);
                    
                    if (data.legal_moves && data.legal_moves.length > 0) {
                        console.log('üï∑Ô∏è Showing legal moves:', data.legal_moves);
                        this.highlightControlledPieceMoves(data.legal_moves);
                        console.log('üï∑Ô∏è Legal moves for controlled piece displayed:', data.legal_moves);
                    } else {
                        console.log('üï∑Ô∏è No legal moves returned for controlled piece');
                    }
                } catch (error) {
                    console.error('Failed to get legal moves for controlled piece:', error);
                }
            }
            
            refreshBoard() {
                // Force a complete refresh of the board and game state
                console.log('Force refreshing board and game state');
                
                // Store current state
                const currentBoardState = lobbyState?.game_state?.board || {};
                const currentSelection = this.selectedNode ? this.selectedNode.getAttribute('data-id') : null;
                
                // Reinitialize board
                this.initializeBoard();
                
                // Restore game state
                if (Object.keys(currentBoardState).length > 0) {
                    console.log('Restoring board state after refresh:', currentBoardState);
                    this.updateBoardWithPieces(currentBoardState);
                    
                    // Restore selection
                    if (currentSelection) {
                        const nodeToSelect = this.nodes.find(n => n.id === currentSelection);
                        if (nodeToSelect) {
                            nodeToSelect.element.classList.add('selected');
                            this.selectedNode = nodeToSelect.element;
                            this.getLegalMoves(currentSelection);
                        }
                    }
                } else {
                    console.log('No board state to restore after refresh');
                }
                
                // Update captured pieces
                updateCapturedPieces();
                
                // Update spider dice button state after board refresh
                updateSpiderDiceButtonState();
            }
            
            clearCheckIndicators() {
                // Remove any existing check indicators
                const existingIndicators = this.board.querySelectorAll('.check-indicator, .check-line');
                existingIndicators.forEach(indicator => indicator.remove());
            }
            
            async showCheckIndicators() {
                // Clear any existing indicators first
                this.clearCheckIndicators();
                
                if (!lobbyState?.game_state?.game_started) return;
                
                try {
                    // Check both players for check status
                    const colors = ['red', 'blue'];
                    
                    for (const color of colors) {
                        const response = await fetch(`/api/lobby/${document.getElementById('lobby-id').textContent}/check-status?player=${color}`);
                        const data = await response.json();
                        
                        if (data.is_in_check) {
                            await this.drawCheckIndicator(color, data.threatening_pieces);
                        }
                    }
                } catch (error) {
                    console.error('Failed to check for check status:', error);
                }
            }
            
            async drawCheckIndicator(playerInCheck, threateningPieces) {
                if (!threateningPieces || threateningPieces.length === 0) return;
                
                // Find the matron mother position
                const matronMotherNode = this.findMatronMother(playerInCheck);
                if (!matronMotherNode) return;
                
                // Draw indicators for each threatening piece
                threateningPieces.forEach(threat => {
                    this.drawCheckLine(threat.node_id, matronMotherNode.id);
                    this.drawSwordIcon(threat.node_id, matronMotherNode.id);
                });
            }
            
            findMatronMother(color) {
                const boardState = lobbyState?.game_state?.board || {};
                for (const [nodeId, pieceName] of Object.entries(boardState)) {
                    if (pieceName === `${color}_matron mother`) {
                        return this.nodes.find(n => n.id === nodeId);
                    }
                }
                return null;
            }
            
            drawCheckLine(fromNodeId, toNodeId) {
                const fromNode = this.nodes.find(n => n.id === fromNodeId);
                const toNode = this.nodes.find(n => n.id === toNodeId);
                
                if (!fromNode || !toNode) return;
                
                // Calculate line position and angle
                const fromX = fromNode.x;
                const fromY = fromNode.y;
                const toX = toNode.x;
                const toY = toNode.y;
                
                const deltaX = toX - fromX;
                const deltaY = toY - fromY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                // Create the check line element
                const checkLine = document.createElement('div');
                checkLine.className = 'check-line';
                checkLine.style.left = fromX + 'px';
                checkLine.style.top = fromY + 'px';
                checkLine.style.width = distance + 'px';
                checkLine.style.transformOrigin = '0 50%';
                checkLine.style.transform = `rotate(${angle}deg)`;
                
                this.board.appendChild(checkLine);
            }
            
            drawSwordIcon(fromNodeId, toNodeId) {
                const fromNode = this.nodes.find(n => n.id === fromNodeId);
                const toNode = this.nodes.find(n => n.id === toNodeId);
                
                if (!fromNode || !toNode) return;
                
                // Calculate midpoint
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                
                // Create sword indicator
                const swordIndicator = document.createElement('div');
                swordIndicator.className = 'check-indicator';
                swordIndicator.textContent = '‚öîÔ∏è';
                swordIndicator.style.left = midX + 'px';
                swordIndicator.style.top = midY + 'px';
                
                this.board.appendChild(swordIndicator);
            }
        }

        // Global function to get piece symbols (used by captured pieces display)
        function getPieceSymbol(pieceName) {
            if (!GameLogic) {
                console.error('üéØ GameLogic not available!');
                return pieceName;
            }
            if (!GAME_CONFIG) {
                console.error('üéØ GAME_CONFIG not available!');
                return pieceName;
            }            
            const symbol = GameLogic.getPieceSymbol(pieceName);
            return symbol;
        }

        async function initializeGameBoard() {
            console.log('üéØ Initializing game board...');
            gameBoard = new MolecularBoard();
            
            // Wait for the board to be fully initialized
            let attempts = 0;
            const maxAttempts = 100; // Wait up to 10 seconds
            
            while ((!gameBoard.nodes || gameBoard.nodes.length === 0) && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (gameBoard.nodes && gameBoard.nodes.length > 0) {
                console.log('üéØ Board initialized with', gameBoard.nodes.length, 'nodes');
                
                // If we already have game state, restore it immediately
                if (lobbyState && lobbyState.game_state && lobbyState.game_state.board) {
                    console.log('üéØ Restoring game state after board initialization...');
                    console.log('üéØ Board state:', lobbyState.game_state.board);
                    gameBoard.updateBoardWithPieces(lobbyState.game_state.board);
                    
                    // Also update captured pieces if available
                    if (lobbyState.game_state.captured_pieces) {
                        updateCapturedPieces();
                    }
                    
                    // Update spider dice button state after board initialization
                    updateSpiderDiceButtonState();
                } else {
                    console.log('üéØ No game state to restore yet');
                }
            } else {
                console.error('üéØ Board failed to initialize properly');
            }
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', async () => {
            if (playerId && socket) {
                const lobbyId = document.getElementById('lobby-id').textContent;
                
                // Leave the WebSocket room
                socket.emit('leave_lobby', {
                    lobby_id: lobbyId,
                    player_id: playerId
                });
                
                // Also call the API to ensure cleanup
                try {
                    await fetch(`/api/lobby/${lobbyId}/leave`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            player_id: playerId
                        })
                    });
                } catch (error) {
                    console.error('Failed to leave lobby:', error);
                }
            }
        });

        // Initialize development features based on config
        function initializeDevelopmentFeatures() {
            const isDevMode = GAME_CONFIG?.development?.enabled;
            
            if (!isDevMode) {
                console.log('üèóÔ∏è Development mode disabled - hiding dev features');
                document.body.classList.remove('dev-mode');
                return;
            }
            
            console.log('üîß Development mode enabled - showing all dev features');
            
            // Enable development mode class for CSS styling
            document.body.classList.add('dev-mode');
            
            // Enable all development features
            window.DEV_LOGGING = true;
            window.SHOW_PLAYER_IDS = true;
            window.SHOW_COORDINATES = true;
            
            // Setup development shortcuts
            setupDevelopmentShortcuts();
            
            console.log('‚úÖ Development features initialized');
        }

        // Setup development keyboard shortcuts
        function setupDevelopmentShortcuts() {
            document.addEventListener('keydown', function(event) {
                // Only in development mode and if not typing in an input
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Ctrl+R: Refresh board
                if (event.ctrlKey && event.key === 'r') {
                    event.preventDefault();
                    if (gameBoard) {
                        gameBoard.refreshBoard();
                        console.log('üîÑ Board refreshed via keyboard shortcut');
                    }
                }
                
                // Ctrl+D: Toggle detailed logging
                if (event.ctrlKey && event.key === 'd') {
                    event.preventDefault();
                    window.DEV_LOGGING = !window.DEV_LOGGING;
                    console.log('üìã Development logging toggled:', window.DEV_LOGGING);
                }
                
                // Ctrl+L: Show lobby state
                if (event.ctrlKey && event.key === 'l') {
                    event.preventDefault();
                    console.log('üè† Current lobby state:', lobbyState);
                }
                
                // Ctrl+Shift+D: Toggle development mode
                if (event.ctrlKey && event.shiftKey && event.key === 'D') {
                    event.preventDefault();
                    toggleDevelopmentMode();
                }
            });
            
            console.log('‚å®Ô∏è Development shortcuts enabled:');
            console.log('  Ctrl+R: Refresh board');
            console.log('  Ctrl+D: Toggle debug logging');
            console.log('  Ctrl+L: Show lobby state');
            console.log('  Ctrl+Shift+D: Toggle development mode');
        }

        // Enhanced logging function that respects dev settings
        function devLog(message, ...args) {
            if (window.DEV_LOGGING) {
                console.log(message, ...args);
            }
        }

        // Toggle development mode at runtime
        function toggleDevelopmentMode() {
            const isCurrentlyEnabled = document.body.classList.contains('dev-mode');
            
            if (isCurrentlyEnabled) {
                document.body.classList.remove('dev-mode');
                window.DEV_LOGGING = false;
                window.SHOW_PLAYER_IDS = false;
                window.SHOW_COORDINATES = false;
                console.log('üèóÔ∏è Development mode disabled');
            } else {
                document.body.classList.add('dev-mode');
                window.DEV_LOGGING = true;
                window.SHOW_PLAYER_IDS = true;
                console.log('üîß Development mode enabled');
                
                // Refresh the board to update node labels
                if (gameBoard) {
                    gameBoard.refreshBoard();
                }
                
                // Update player display
                updateLobbyDisplay();
            }
        }
        
        // Console helper functions for development (available globally)
        window.devMode = {
            toggle: toggleDevelopmentMode,
            enable: () => {
                document.body.classList.add('dev-mode');
                window.DEV_LOGGING = true;
                window.SHOW_PLAYER_IDS = true;
                console.log('üîß Development mode enabled via console');
                if (gameBoard) gameBoard.refreshBoard();
                updateLobbyDisplay();
            },
            disable: () => {
                document.body.classList.remove('dev-mode');
                window.DEV_LOGGING = false;
                window.SHOW_PLAYER_IDS = false;
                window.SHOW_COORDINATES = false;
                console.log('üèóÔ∏è Development mode disabled via console');
                if (gameBoard) gameBoard.refreshBoard();
                updateLobbyDisplay();
            },
            refresh: () => {
                if (gameBoard) gameBoard.refreshBoard();
                console.log('üîÑ Board refreshed via console');
            },
            state: () => {
                console.log('üè† Current lobby state:', lobbyState);
            }
        };

        // Sidebar toggle functions
        function toggleSidebar() {
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const overlay = document.getElementById('mobile-overlay');
            const isMobile = window.innerWidth <= 768;
            
            console.log('üçî Toggle sidebar clicked, isMobile:', isMobile);
            console.log('üçî Sidebar classes:', sidebar.classList.toString());
            
            if (isMobile) {
                // On mobile, toggle between open/closed overlay
                if (sidebar.classList.contains('open')) {
                    console.log('üì± Mobile: closing sidebar');
                    closeSidebar();
                } else {
                    console.log('üì± Mobile: opening sidebar');
                    openSidebar();
                }
            } else {
                // On desktop, toggle between visible/hidden in grid
                if (sidebar.classList.contains('hamburger-hidden')) {
                    console.log('üñ•Ô∏è Desktop: showing sidebar');
                    openSidebar();
                } else {
                    console.log('üñ•Ô∏è Desktop: hiding sidebar');
                    closeSidebar();
                }
            }
        }

        function openSidebar() {
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const overlay = document.getElementById('mobile-overlay');
            const lobbyContent = document.querySelector('.lobby-content');
            const isMobile = window.innerWidth <= 768;
            
            console.log('üîì Opening sidebar, isMobile:', isMobile);
            
            if (isMobile) {
                // Mobile behavior: overlay sidebar
                sidebar.classList.add('open');
                overlay.classList.add('open');
                document.body.style.overflow = 'hidden';
                console.log('üì± Mobile: sidebar opened as overlay');
            } else {
                // Desktop behavior: show sidebar in grid layout
                sidebar.classList.remove('hamburger-hidden');
                lobbyContent.classList.remove('sidebar-collapsed');
                console.log('üñ•Ô∏è Desktop: sidebar shown in grid');
                
                // Trigger board redraw after a short delay to allow CSS transition
                setTimeout(() => {
                    if (gameBoard) {
                        gameBoard.handleSidebarToggle(false); // false = expanded
                    }
                }, 300);
            }
            
            hamburger.classList.add('active');
            console.log('üçî Hamburger active, sidebar classes:', sidebar.classList.toString());
        }

        function closeSidebar() {
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const overlay = document.getElementById('mobile-overlay');
            const lobbyContent = document.querySelector('.lobby-content');
            const isMobile = window.innerWidth <= 768;
            
            console.log('üîí Closing sidebar, isMobile:', isMobile);
            
            if (isMobile) {
                // Mobile behavior: hide overlay sidebar
                sidebar.classList.remove('open');
                overlay.classList.remove('open');
                document.body.style.overflow = '';
                console.log('üì± Mobile: sidebar closed as overlay');
            } else {
                // Desktop behavior: hide sidebar and expand game board
                sidebar.classList.add('hamburger-hidden');
                lobbyContent.classList.add('sidebar-collapsed');
                console.log('üñ•Ô∏è Desktop: sidebar hidden, grid collapsed');
                
                // Trigger board redraw after a short delay to allow CSS transition
                setTimeout(() => {
                    if (gameBoard) {
                        gameBoard.handleSidebarToggle(true); // true = collapsed
                    }
                }, 300);
            }
            
            hamburger.classList.remove('active');
            console.log('üçî Hamburger inactive, sidebar classes:', sidebar.classList.toString());
        }

        // Close sidebar with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeSidebar();
            }
        });
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile && sidebar.classList.contains('open')) {
                // If clicking outside sidebar and hamburger button on mobile, close sidebar
                if (!sidebar.contains(event.target) && !hamburger.contains(event.target)) {
                    closeSidebar();
                }
            }
        });

        // Check if device is mobile and set initial sidebar state
        function initializeMobileLayout() {
            const isMobile = window.innerWidth <= 768;
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const lobbyContent = document.querySelector('.lobby-content');
            const overlay = document.getElementById('mobile-overlay');
            
            if (isMobile) {
                // On mobile, sidebar starts closed (overlay mode)
                sidebar.classList.remove('open');
                overlay.classList.remove('open');
                hamburger.classList.remove('active');
                document.body.style.overflow = '';
                console.log('üì± Mobile layout detected - sidebar collapsed');
            } else {
                // On desktop, sidebar starts visible in grid layout
                sidebar.classList.remove('hamburger-hidden');
                sidebar.classList.remove('open'); // Remove mobile overlay class
                lobbyContent.classList.remove('sidebar-collapsed');
                overlay.classList.remove('open');
                hamburger.classList.remove('active');
                console.log('üñ•Ô∏è Desktop layout detected - sidebar visible in grid');
            }
        }

        // Handle window resize for responsive behavior
        function handleResize() {
            const isMobile = window.innerWidth <= 768;
            const sidebar = document.querySelector('.lobby-sidebar');
            const hamburger = document.getElementById('hamburger-menu');
            const lobbyContent = document.querySelector('.lobby-content');
            const overlay = document.getElementById('mobile-overlay');
            
            // Clear all classes and reset
            sidebar.classList.remove('open', 'hamburger-hidden');
            lobbyContent.classList.remove('sidebar-collapsed');
            overlay.classList.remove('open');
            document.body.style.overflow = '';
            
            if (isMobile) {
                // Mobile: start with sidebar closed
                hamburger.classList.remove('active');
                console.log('üì± Switched to mobile layout');
            } else {
                // Desktop: start with sidebar visible in grid
                hamburger.classList.remove('active');
                // console.log('üñ•Ô∏è Switched to desktop layout');
            }
            
            // If we have a game board, trigger a redraw to handle the new layout
            if (gameBoard && !isMobile) {
                setTimeout(() => {
                    gameBoard.handleSidebarToggle(false); // false = expanded (default desktop state)
                }, 100);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeDevelopmentFeatures();
            initializeLobby();
            initializeMobileLayout();
            
            // Fallback: if board still isn't initialized after a short delay, try to initialize it
            setTimeout(() => {
                if (!gameBoard && lobbyState) {
                    console.log('Fallback: Initializing game board after delay...');
                    initializeGameBoard();
                }
            }, 1000);
        });

        // Listen for window resize
        window.addEventListener('resize', handleResize);

        // Game over handling functions
        function handleGameOver(gameData) {
            const { winner, game_end_reason } = gameData;
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            
            // console.log('üéÆ HandleGameOver called:', { gameData, currentPlayer, playerId });
            
            if (!currentPlayer) {
                console.log('‚ùå No current player found, exiting handleGameOver');
                return;
            }
            
            const isWinner = winner === currentPlayer.color;
            const isLoser = winner && winner !== currentPlayer.color;
            
            console.log('üéÆ Game over analysis:', { 
                winner, 
                currentPlayerColor: currentPlayer.color, 
                isWinner, 
                isLoser, 
                game_end_reason 
            });
            
            // Update status text
            let statusText = '';
            if (game_end_reason === 'checkmate') {
                if (isWinner) {
                    statusText = `üéâ CHECKMATE! You win!`;
                } else if (isLoser) {
                    statusText = `üíÄ CHECKMATE! You lose!`;
                } else {
                    statusText = `üéâ CHECKMATE! ${winner} player wins!`;
                }
            } else if (game_end_reason === 'stalemate') {
                if (isWinner) {
                    statusText = `üéØ STALEMATE! You win! (Opponent has no legal moves)`;
                } else if (isLoser) {
                    statusText = `üíÄ STALEMATE! You lose! (No legal moves available)`;
                } else {
                    statusText = `üéØ STALEMATE! ${winner} player wins!`;
                }
            } else if (game_end_reason === 'timeout') {
                if (isWinner) {
                    statusText = `‚è∞ TIMEOUT! You win! (Opponent ran out of time)`;
                } else if (isLoser) {
                    statusText = `‚è∞ TIMEOUT! You lose! (Time's up!)`;
                } else {
                    statusText = `‚è∞ TIMEOUT! ${winner} player wins!`;
                }
            }
            
            document.getElementById('status-text').innerHTML = statusText;
            
            // Show game over overlay
            showGameOverOverlay(gameData);
            
            // Trigger visual effects
            if (isWinner) {
                triggerConfetti();
            } else if (isLoser) {
                triggerRain();
            } else {
                console.log('üëÄ No animation triggered - player is spectator or other reason');
            }
        }

        function showGameOverOverlay(gameData) {
            const { winner, game_end_reason } = gameData;
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            
            let title = 'Game Over';
            let message = 'The game has ended';
            
            if (game_end_reason === 'checkmate') {
                if (winner === currentPlayer?.color) {
                    title = 'üéâ VICTORY!';
                    message = 'Congratulations! You won by checkmate!';
                } else if (winner) {
                    title = 'üíÄ DEFEAT!';
                    message = `You lost by checkmate. ${winner} player wins!`;
                }
            } else if (game_end_reason === 'stalemate') {
                if (winner === currentPlayer?.color) {
                    title = 'üéØ VICTORY!';
                    message = 'Congratulations! You won by stalemate! Your opponent had no legal moves.';
                } else if (winner) {
                    title = 'üíÄ DEFEAT!';
                    message = `You lost by stalemate. You had no legal moves available. ${winner} player wins!`;
                } else {
                    title = 'üéØ STALEMATE!';
                    message = `Game ended by stalemate. ${winner} player wins!`;
                }
            } else if (game_end_reason === 'timeout') {
                if (winner === currentPlayer?.color) {
                    title = '‚è∞ VICTORY!';
                    message = 'Congratulations! You won because your opponent ran out of time!';
                } else if (winner) {
                    title = '‚è∞ DEFEAT!';
                    message = `You lost by timeout. Time\'s up! ${winner} player wins!`;
                } else {
                    title = '‚è∞ TIMEOUT!';
                    message = `Game ended by timeout. ${winner} player wins!`;
                }
            }
            
            document.getElementById('game-over-title').textContent = title;
            document.getElementById('game-over-message').textContent = message;
            document.getElementById('game-over-overlay').style.display = 'flex';
        }

        function closeGameOverOverlay() {
            document.getElementById('game-over-overlay').style.display = 'none';
        }

        function triggerConfetti() {
            
            // Check if confetti library is available
            if (typeof confetti === 'undefined') {
                console.error('‚ùå Confetti library not loaded!');
                return;
            }
            
            // Create confetti effect
            const duration = 3000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);
                
                // Create confetti
                confetti(Object.assign({}, defaults, {
                    particleCount,
                    origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                }));
                confetti(Object.assign({}, defaults, {
                    particleCount,
                    origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                }));
            }, 250);
        }

        function triggerRain() {
            const rainContainer = document.getElementById('rain-container');
            const raindropCount = 100;
            
            // Clear existing raindrops
            rainContainer.innerHTML = '';
            
            // Create raindrops
            for (let i = 0; i < raindropCount; i++) {
                const raindrop = document.createElement('div');
                raindrop.className = 'raindrop';
                raindrop.style.left = Math.random() * 100 + 'vw';
                raindrop.style.animationDelay = Math.random() * 2 + 's';
                raindrop.style.animationDuration = (Math.random() * 1 + 1) + 's';
                rainContainer.appendChild(raindrop);
            }
            
            // Stop rain after 5 seconds
            setTimeout(() => {
                rainContainer.innerHTML = '';
            }, 5000);
        }

        // Rules sidebar functions
        async function openRulesSidebar() {
            // Load rules content if not already loaded
            if (!document.getElementById('rules-content').hasAttribute('data-loaded')) {
                await loadRulesContent();
            }
            
            document.getElementById('rules-sidebar').classList.add('open');
            document.getElementById('rules-overlay').classList.add('open');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        async function loadRulesContent() {
            try {
                const response = await fetch('/rules');
                const html = await response.text();
                
                // Extract the rules content from the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const rulesContent = doc.querySelector('.rules-content');
                
                if (rulesContent) {
                    // Replace the loading content with the actual rules
                    document.getElementById('rules-content').innerHTML = rulesContent.innerHTML;
                    document.getElementById('rules-content').setAttribute('data-loaded', 'true');
                } else {
                    throw new Error('Rules content not found');
                }
            } catch (error) {
                console.error('Failed to load rules:', error);
                document.getElementById('rules-content').innerHTML = 
                    '<div class="error">Failed to load rules. Please try again.</div>';
            }
        }

        function closeRulesSidebar() {
            document.getElementById('rules-sidebar').classList.remove('open');
            document.getElementById('rules-overlay').classList.remove('open');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Close sidebar when clicking overlay
        document.getElementById('rules-overlay').addEventListener('click', closeRulesSidebar);

        // Close sidebar with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeRulesSidebar();
            }
        });
        
        // Spider dice helper functions
        let audioContext = null;
        
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.warn('Audio context not supported:', error);
                }
            }
        }
        
        function playDiceRollSound() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.warn('Failed to play dice roll sound:', error);
            }
        }
        
        function playDoubleSpiderSound() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (error) {
                console.warn('Failed to play double spider sound:', error);
            }
        }
        
        function showDiceResult(die1, die2, die1Spider, die2Spider, bothSpiders, bothKnives) {
            const diceResult = document.getElementById('dice-result');
            const die1Element = document.getElementById('die1');
            const die2Element = document.getElementById('die2');
            const diceMessage = document.getElementById('dice-message');
            
            // Stop rolling animation
            die1Element.className = 'die';
            die2Element.className = 'die';
            
            // Show final results
            die1Element.textContent = die1Spider ? 'üï∑Ô∏è' : 'üî™';
            die2Element.textContent = die2Spider ? 'üï∑Ô∏è' : 'üî™';
            
            // Add bounce animation
            die1Element.classList.add('bounce');
            die2Element.classList.add('bounce');
            
            // Update message
            if (bothSpiders) {
                diceMessage.innerHTML = '<strong>üï∑Ô∏èüï∑Ô∏è DOUBLE SPIDERS!</strong><br>The spider queen bestows a boon...';
                playDoubleSpiderSound();
                triggerConfetti();
            } else if (bothKnives) {
                diceMessage.innerHTML = '<strong>üî™üî™ Both knives!</strong><br>The spider queen demands sacrifice!';
            } else {
                const spiderCount = (die1Spider ? 1 : 0) + (die2Spider ? 1 : 0);
                diceMessage.innerHTML = `<strong>${spiderCount} spider${spiderCount !== 1 ? 's' : ''}!</strong><br>${spiderCount === 1 ? 'The spider queen ignores your prayers...' : 'No special effects.'}`;
            }
            
            // Remove bounce animation after a delay
            setTimeout(() => {
                die1Element.classList.remove('bounce');
                die2Element.classList.remove('bounce');
            }, 1000);
        }
        
        function closeDiceResult() {
            const diceResult = document.getElementById('dice-result');
            diceResult.classList.remove('show');
        }
        
        function updateSpiderDiceButtonState() {
            if (!lobbyState || !lobbyState.game_state) {
                console.log('üé≤ No lobby state available for spider dice button update');
                return;
            }
            
            const spiderDiceBtn = document.getElementById('spider-dice-btn');
            if (!spiderDiceBtn) {
                console.log('üé≤ Spider dice button not found');
                return;
            }
            
            const gameState = lobbyState.game_state;
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            
            if (!currentPlayer) {
                console.log('üé≤ Current player not found');
                return;
            }
            
            // Check if it's the current player's turn
            const isCurrentTurn = currentPlayer.color === gameState.current_turn;
            
            // Check if the game has started
            const gameStarted = gameState.game_started;
            
            // Check if the button should be enabled based on turn number and cooldown
            let shouldEnable = false;
            let reason = '';
            
            if (!gameStarted) {
                shouldEnable = false;
                reason = 'Game not started';
            } else if (!isCurrentTurn) {
                shouldEnable = false;
                reason = 'Not your turn';
            } else {
                // Check turn number requirement using game config
                const spiderDiceMinTurn = GAME_CONFIG?.game_rules?.spider_dice_min_turn || 3;
                const playerTurnCount = gameState.player_turn_numbers?.[currentPlayer.color] || 0;
                if (playerTurnCount < spiderDiceMinTurn) {
                    shouldEnable = false;
                    reason = `Must wait until turn ${spiderDiceMinTurn - playerTurnCount} more`;
                } else {
                    shouldEnable = true;
                    reason = 'Ready to roll';
                }
            }
            
            // console.log('üé≤ Spider dice button state:', {
            //     shouldEnable,
            //     reason,
            //     player_turn_count: gameState.player_turn_numbers?.[currentPlayer.color] || 0,
            //     current_turn: gameState.current_turn,
            //     player_color: currentPlayer.color,
            //     spider_dice_min_turn: GAME_CONFIG?.game_rules?.spider_dice_min_turn || 3,
            //     explanation: `Player has completed ${gameState.player_turn_numbers?.[currentPlayer.color] || 0} turns - needs ${GAME_CONFIG?.game_rules?.spider_dice_min_turn || 3} to use spider dice`
            // });
            
            // Update button state
            spiderDiceBtn.disabled = !shouldEnable;
            
            // Update button text and styling
            if (shouldEnable) {
                spiderDiceBtn.textContent = 'üï∑Ô∏è Roll Spider Dice';
                spiderDiceBtn.classList.remove('disabled');
                spiderDiceBtn.title = 'Roll two d8 dice: 5-8 = üï∑Ô∏è (spider), 1-4 = üî™ (knife). Double spiders trigger special effects!';
            } else {
                spiderDiceBtn.textContent = `üï∑Ô∏è ${reason}`;
                spiderDiceBtn.classList.add('disabled');
                spiderDiceBtn.title = `Spider dice unavailable: ${reason}`;
            }
        }
        
        function updateGameStatus() {
            if (!lobbyState || !lobbyState.game_state) {
                return;
            }
            
            const gameState = lobbyState.game_state;
            const statusText = document.getElementById('status-text');
            const statusIndicator = document.getElementById('status-indicator');
            
            if (!gameState.game_started) {
                statusText.textContent = 'Waiting for players to join...';
                statusIndicator.className = 'status-indicator status-waiting';
                return;
            }
            
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            if (!currentPlayer) {
                statusText.textContent = 'Error: Player not found';
                return;
            }
            
            const isCurrentTurn = currentPlayer.color === gameState.current_turn;
            const currentTurnColor = gameState.current_turn;
            
            if (isCurrentTurn) {
                statusText.textContent = `Your turn (${currentTurnColor})`;
                statusIndicator.className = 'status-indicator status-active';
            } else {
                statusText.textContent = `${currentTurnColor.charAt(0).toUpperCase() + currentTurnColor.slice(1)}'s turn`;
                statusIndicator.className = 'status-indicator status-waiting';
            }
            
            // Update spider dice button state
            updateSpiderDiceButtonState();
        }
        
        // Orc Promotion Functions
        let selectedPromotionPiece = null;
        
        function showPromotionModal(data) {
            const { promotable_pieces, promotion_node, player } = data;
            
            // Check if this promotion is for the current player
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            if (!currentPlayer || currentPlayer.color !== player) {
                console.log('Promotion not for current player, ignoring');
                return;
            }
            
            console.log('üîÑ Showing promotion modal for pieces:', promotable_pieces);
            
            const modal = document.getElementById('promotion-overlay');
            const piecesContainer = document.getElementById('promotion-pieces');
            const confirmBtn = document.getElementById('promotion-confirm-btn');
            
            // Clear previous pieces
            piecesContainer.innerHTML = '';
            selectedPromotionPiece = null;
            
            // Update confirm button
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'Select a piece first';
            
            // Add available pieces
            promotable_pieces.forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'promotion-piece';
                pieceElement.setAttribute('data-piece', piece);
                
                const symbol = getPieceSymbol(piece);
                const name = piece.split('_')[1].replace(/[0-9]/g, '');
                
                pieceElement.innerHTML = `
                    <div class="promotion-piece-symbol">${symbol}</div>
                    <div class="promotion-piece-name">${name}</div>
                `;
                
                pieceElement.onclick = () => selectPromotionPiece(piece, pieceElement);
                piecesContainer.appendChild(pieceElement);
            });
            
            // Show modal
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        
        function selectPromotionPiece(piece, element) {
            // Remove previous selection
            document.querySelectorAll('.promotion-piece').forEach(p => p.classList.remove('selected'));
            
            // Select new piece
            element.classList.add('selected');
            selectedPromotionPiece = piece;
            
            // Update confirm button
            const confirmBtn = document.getElementById('promotion-confirm-btn');
            confirmBtn.disabled = false;
            confirmBtn.textContent = `Promote to ${piece.split('_')[1].replace(/[0-9]/g, '')}`;
        }
        
        function confirmPromotion() {
            if (!selectedPromotionPiece) return;
            
            const lobbyId = document.getElementById('lobby-id').textContent;
            
            // Send promotion via WebSocket
            socket.emit('promote_orc', {
                lobby_id: lobbyId,
                selected_piece: selectedPromotionPiece,
                player_id: playerId
            });
            
            console.log('üîÑ Promoting orc to:', selectedPromotionPiece);
        }
        
        function closePromotionModal() {
            const modal = document.getElementById('promotion-overlay');
            modal.classList.remove('show');
            document.body.style.overflow = '';
            selectedPromotionPiece = null;
        }
        
        // Timer Variables and Functions
        let turnTimerInterval = null;
        let currentTurnStartTime = null;
        let timeoutTriggered = false;

        function getTimerConfig() {
            // Get timer limit from game config, default to 600 seconds (10 minutes)
            return GameLogic.getConfig('game_rules.turn_time_limit_seconds', 600);
        }

        function formatTime(seconds) {
            if (seconds <= 0) return "00:00";
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const gameState = lobbyState?.game_state;
            if (!gameState || !gameState.game_started) {
                document.getElementById('turn-timer').style.display = 'none';
                return;
            }

            // Show timer
            document.getElementById('turn-timer').style.display = 'block';

            // Update player timers
            const redTime = gameState.player_time_remaining?.red || 0;
            const blueTime = gameState.player_time_remaining?.blue || 0;
            
            const redTimerEl = document.getElementById('red-timer');
            const blueTimerEl = document.getElementById('blue-timer');
            
            redTimerEl.textContent = formatTime(redTime);
            blueTimerEl.textContent = formatTime(blueTime);

            // Timer sections already have the red/blue classes in HTML

            // Add warning/danger classes based on configured timer limit
            const timerLimit = getTimerConfig();
            const warningThreshold = Math.max(120, timerLimit * 0.2); // 20% of time or 2 minutes, whichever is greater
            const dangerThreshold = Math.max(60, timerLimit * 0.1);   // 10% of time or 1 minute, whichever is greater
            
            redTimerEl.className = 'timer-value';
            blueTimerEl.className = 'timer-value';
            
            if (redTime <= dangerThreshold) redTimerEl.className += ' danger';
            else if (redTime <= warningThreshold) redTimerEl.className += ' warning';
            
            if (blueTime <= dangerThreshold) blueTimerEl.className += ' danger';
            else if (blueTime <= warningThreshold) blueTimerEl.className += ' warning';

            // Update current turn timer
            updateCurrentTurnTimer(gameState);
        }

        function updateCurrentTurnTimer(gameState) {
            if (!gameState.turn_start_time) return;
            
            const currentTime = Date.now() / 1000;
            const turnStartTime = gameState.turn_start_time;
            const elapsedThisTurn = currentTime - turnStartTime;
            
            const currentTurnTimerEl = document.getElementById('current-turn-timer');
            currentTurnTimerEl.textContent = formatTime(elapsedThisTurn);
            
            // Check for timeout - if elapsed time this turn would exhaust remaining time
            const currentPlayer = gameState.current_turn;
            const remainingTimeAtTurnStart = gameState.player_time_remaining?.[currentPlayer] || 0;
            
            // Player times out if they've used up all their remaining time
            if (remainingTimeAtTurnStart > 0 && elapsedThisTurn >= remainingTimeAtTurnStart && !timeoutTriggered) {
                console.log(`‚è∞ TIMEOUT DETECTED: ${currentPlayer} used ${elapsedThisTurn.toFixed(1)}s but only had ${remainingTimeAtTurnStart.toFixed(1)}s remaining`);
                timeoutTriggered = true;
                handlePlayerTimeout();
            }
        }

        function startTurnTimer() {
            // Clear existing timer
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
            }
            
            // Reset timeout flag for new turn
            timeoutTriggered = false;
            
            // Start new timer that updates every second
            turnTimerInterval = setInterval(() => {
                if (lobbyState?.game_state?.game_started && !lobbyState?.game_state?.game_over) {
                    updateCurrentTurnTimer(lobbyState.game_state);
                }
            }, 1000);
        }

        function stopTurnTimer() {
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }
        }

        function handlePlayerTimeout() {
            const gameState = lobbyState?.game_state;
            if (!gameState || gameState.game_over) {
                console.log('‚è∞ Timeout ignored: game not active or already over');
                return;
            }
            
            const currentPlayer = lobbyState?.players?.find(p => p.id === playerId);
            if (!currentPlayer || currentPlayer.color !== gameState.current_turn) {
                console.log('‚è∞ Timeout ignored: not our turn');
                return; // Not our turn, so we can't time out
            }
            
            console.log('‚è∞ Player timed out, sending timeout event to server');
            
            // Send timeout event to server
            const lobbyId = document.getElementById('lobby-id').textContent;
            socket.emit('player_timeout', {
                lobby_id: lobbyId,
                player_id: playerId
            });
            
            // Stop the timer
            stopTurnTimer();
        }


    </script>
</body>
</html> 