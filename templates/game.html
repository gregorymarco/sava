<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sava</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem 0;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 90%;
            margin: 0 auto;
            text-align: center;
        }

        .header {
            margin-bottom: 2rem;
        }

        .logo {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h1 {
            color: #333;
            margin-bottom: 1rem;
            font-size: 2.5rem;
            font-weight: 300;
        }

        .subtitle {
            color: #666;
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f0f0f0;
        }

        .nav-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .game-board-container {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 2rem auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .game-board {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .node {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            z-index: 10;
        }

        .node:hover {
            background: #e8c39e;
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .node.selected {
            background: #ff6b6b;
            border-color: #d63031;
        }

        .strand {
            position: absolute;
            background: #333;
            z-index: 5;
        }

        .strand.vertical {
            width: 2px;
        }

        .strand.horizontal {
            height: 2px;
        }

        .strand.ring {
            border: 2px solid #333;
            border-radius: 50%;
            background: transparent;
        }

        .status {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">‚ôî‚ôõ</div>
            <h1>Sava</h1>
            <p class="subtitle">A turn-based strategy game with a unique board</p>
        </div>

        <div class="nav-bar">
            <a href="/" class="nav-btn">‚Üê Back to Home</a>
            <a href="/rules" class="nav-btn">üìñ Rules</a>
        </div>
        
        <div class="game-board-container">
            <div class="game-board" id="game-board">
                <!-- Nodes and strands will be created by JavaScript -->
            </div>
        </div>
        
        <div class="status" id="status">
            <strong>Welcome!</strong> Click on any node to start the game.
        </div>
        
        <div>
            <button class="btn" hx-get="/api/hello" hx-target="#status">
                Test API
            </button>
            <button class="btn" onclick="resetBoard()">
                Reset Board
            </button>
        </div>
    </div>

    <script>
        class MolecularBoard {
            constructor() {
                this.board = document.getElementById('game-board');
                this.nodes = [];
                this.selectedNode = null;
                this.centerX = 300;
                this.centerY = 300;
                this.initializeBoard();
            }

            initializeBoard() {
                this.board.innerHTML = '';
                this.nodes = [];
                
                // Create center nodes (4 nodes in a square)
                const centerOffset = 30;
                const centerPositions = [
                    {x: this.centerX - centerOffset, y: this.centerY - centerOffset},
                    {x: this.centerX + centerOffset, y: this.centerY - centerOffset},
                    {x: this.centerX - centerOffset, y: this.centerY + centerOffset},
                    {x: this.centerX + centerOffset, y: this.centerY + centerOffset}
                ];

                centerPositions.forEach((pos, index) => {
                    this.createNode(pos.x, pos.y, `C${index}`, 'center');
                });

                // Create concentric rings
                const ringRadii = [80, 160, 240];
                ringRadii.forEach((radius, ringIndex) => {
                    this.createRing(radius, ringIndex + 1);
                });

                // Create connecting strands
                this.createStrands();
            }

            createNode(x, y, id, type) {
                const node = document.createElement('div');
                node.className = 'node';
                node.style.left = (x - 10) + 'px';
                node.style.top = (y - 10) + 'px';
                node.setAttribute('data-id', id);
                node.setAttribute('data-type', type);
                node.setAttribute('data-x', x);
                node.setAttribute('data-y', y);
                node.textContent = id;
                node.addEventListener('click', (e) => this.handleNodeClick(e));
                
                this.board.appendChild(node);
                this.nodes.push({id, x, y, type, element: node});
            }

            createRing(radius, ringIndex) {
                const nodesPerRing = 16;
                for (let i = 0; i < nodesPerRing; i++) {
                    const angle = (i * 2 * Math.PI) / nodesPerRing;
                    const x = this.centerX + radius * Math.cos(angle);
                    const y = this.centerY + radius * Math.sin(angle);
                    const id = `R${ringIndex}N${i}`;
                    this.createNode(x, y, id, `ring${ringIndex}`);
                }
            }

            createStrands() {
                // Ring strands (circular)
                const ringRadii = [80, 160, 240];
                ringRadii.forEach((radius, index) => {
                    const ringStrand = document.createElement('div');
                    ringStrand.className = 'strand ring';
                    ringStrand.style.left = (this.centerX - radius) + 'px';
                    ringStrand.style.top = (this.centerY - radius) + 'px';
                    ringStrand.style.width = (radius * 2) + 'px';
                    ringStrand.style.height = (radius * 2) + 'px';
                    this.board.appendChild(ringStrand);
                });

                // Additional connecting strands through specific nodes
                this.createNodeConnections();
            }

            createNodeConnections() {
                // Create SVG for curved strands
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '600');
                svg.setAttribute('height', '600');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.zIndex = '5';
                this.board.appendChild(svg);

                // Vertical strand 1: R3N11 -> R2N11 -> R1N11 -> C0 -> C2 -> R1N5 -> R2N5 -> R3N5
                this.createCurvedStrand(svg, [
                    'R3N11', 'R2N11', 'R1N11', 'C0', 'C2', 'R1N5', 'R2N5', 'R3N5'
                ], 'vertical');

                // Vertical strand 2 (mirrored): R3N13 -> R2N13 -> R1N13 -> C1 -> C3 -> R1N3 -> R2N3 -> R3N3
                this.createCurvedStrand(svg, [
                    'R3N13', 'R2N13', 'R1N13', 'C1', 'C3', 'R1N3', 'R2N3', 'R3N3'
                ], 'vertical');

                // Horizontal strand 1: R3N7 -> R2N7 -> R1N7 -> C2 -> C3 -> R1N1 -> R2N1 -> R3N1
                this.createCurvedStrand(svg, [
                    'R3N7', 'R2N7', 'R1N7', 'C2', 'C3', 'R1N1', 'R2N1', 'R3N1'
                ], 'horizontal');

                // Horizontal strand 2 (mirrored): R3N9 -> R2N9 -> R1N9 -> C0 -> C1 -> R1N15 -> R2N15 -> R3N15
                this.createCurvedStrand(svg, [
                    'R3N9', 'R2N9', 'R1N9', 'C0', 'C1', 'R1N15', 'R2N15', 'R3N15'
                ], 'horizontal');
            }

            createCurvedStrand(svg, nodeIds, direction) {
                const nodes = nodeIds.map(id => this.nodes.find(n => n.id === id)).filter(n => n);
                
                if (nodes.length < 2) return;

                // Create path through node centers
                let pathData = '';
                
                nodes.forEach((node, index) => {
                    const x = node.x;
                    const y = node.y;
                    
                    if (index === 0) {
                        pathData += `M ${x} ${y}`;
                    } else {
                        // Calculate control points for smooth curves
                        const prevNode = nodes[index - 1];
                        const nextNode = nodes[index + 1];
                        
                        if (nextNode) {
                            // Use quadratic curve for smooth transitions
                            const midX = (x + prevNode.x) / 2;
                            const midY = (y + prevNode.y) / 2;
                            pathData += ` Q ${midX} ${midY} ${x} ${y}`;
                        } else {
                            // Last node, just line to it
                            pathData += ` L ${x} ${y}`;
                        }
                    }
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#333');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                
                svg.appendChild(path);
            }

            handleNodeClick(event) {
                const node = event.target;
                const nodeId = node.getAttribute('data-id');
                
                // Remove previous selection
                if (this.selectedNode) {
                    this.selectedNode.classList.remove('selected');
                }
                
                // Select new node
                node.classList.add('selected');
                this.selectedNode = node;
                
                document.getElementById('status').innerHTML = 
                    `<strong>Node ${nodeId} selected!</strong> This is where game logic will be implemented.`;
            }
        }

        let gameBoard;

        // Initialize the board when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            gameBoard = new MolecularBoard();
        });
    </script>
</body>
</html> 